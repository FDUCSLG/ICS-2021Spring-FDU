<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>实验 1 - Introduction to NSCSCC</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../schedule.html">课程安排</a></li><li class="chapter-item expanded "><a href="../arch-lab/index.html">体系结构部分</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../arch-lab/lab0.html">实验 0</a></li><li class="chapter-item expanded "><a href="../arch-lab/lab1.html" class="active">实验 1</a></li><li class="chapter-item "><a href="../arch-lab/lab2a.html">实验 2a</a></li><li class="chapter-item "><a href="../arch-lab/lab2b.html">实验 2b</a></li><li class="chapter-item "><a href="../arch-lab/lab3a.html">实验 3a</a></li><li class="chapter-item "><a href="../arch-lab/lab3b.html">实验 3b</a></li><li class="chapter-item "><a href="../arch-lab/lab4.html">实验 4</a></li></ol></li><li class="chapter-item expanded "><a href="../project/index.html">挑战课题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../project/task1.html">流水线性能优化</a></li></ol></li><li class="chapter-item expanded "><a href="../misc/index.html">附加资料</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../misc/external.html">外部资料</a></li><li class="chapter-item "><a href="../misc/instruction.html">指令列表</a></li><li class="chapter-item "><a href="../misc/fpga.html">了解 FPGA 架构</a></li><li class="chapter-item "><a href="../misc/verilate.html">Verilator 仿真</a></li><li class="chapter-item "><a href="../misc/unopt.html">组合逻辑环与 UNOPT</a></li><li class="chapter-item "><a href="../misc/gtkwave.html">使用 GTKWave</a></li></ol></li><li class="chapter-item expanded "><a href="../directory-structure.html">仓库目录结构</a></li><li class="chapter-item expanded affix "><a href="../faq.html">常见问题</a></li><li class="chapter-item expanded affix "><a href="../contributors.html">贡献者</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Introduction to NSCSCC</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-1五级流水线-mips-cpu"><a class="header" href="#实验-1五级流水线-mips-cpu">实验 1：五级流水线 MIPS CPU</a></h1>
<blockquote>
<p>先修内容：《深入学习计算机系统》Chapter 4: Pipelined Y86 CPU</p>
</blockquote>
<h2 id="11-mips-微体系结构"><a class="header" href="#11-mips-微体系结构">1.1 MIPS 微体系结构</a></h2>
<p>五级流水线，属于体系结构的范畴。不同指令集的 CPU，都可以有五级流水线的实现。</p>
<p>指令集是微体系结构的一部分，规范了指令编码等信息。</p>
<p>MIPS 属于精简指令集（Reduced Instruction Set Computing，RISC）。我们需要实现的 MIPS，部分基本信息如下：</p>
<ul>
<li>每条指令长度为 4 字节（32 位）。</li>
<li>32 个通用寄存器，每个寄存器 32 位。0 号寄存器只读恒为 0。</li>
<li>内存读写的最小单位为 1 字节（8 位）。</li>
</ul>
<h3 id="111-mips-指令集"><a class="header" href="#111-mips-指令集">1.1.1 MIPS 指令集</a></h3>
<p>详见 <a href="../misc/external.html#mips-%E6%9E%B6%E6%9E%84">MIPS 手册 Ⅱ</a>：<i class="fa fa-file-pdf-o"></i> Volume II: MIPS32 Instruction Set。</p>
<p>这里介绍一下本实验中将要实现的部分指令：</p>
<hr />
<p><code>01ae5821		addu t3,t5,t6</code></p>
<table><thead><tr><th>[31:26]:000000</th><th>[25:21]:01101</th><th>[20:16]:01110</th><th>[15:11]:01011</th><th>[10:6]:00000</th><th>[5:0]:100001</th></tr></thead><tbody>
<tr><td>指令类型：寄存器类型</td><td>rs: t5</td><td>rt: t6</td><td>rd: t3</td><td>全 0</td><td>ADDU</td></tr>
</tbody></table>
<p>操作：<code>Reg[rd] ← Reg[rs] + Reg[rt]</code></p>
<hr />
<p><code>25290001		addiu t1,t1,1</code></p>
<table><thead><tr><th>[31:26]:001001</th><th>[25:21]:01001</th><th>[21:16]:01001</th><th>[15:0]:0000_0000_0000_0001</th></tr></thead><tbody>
<tr><td>指令类型：ADDIU</td><td>rs: t1</td><td>rt: t1</td><td>立即数 immediate</td></tr>
</tbody></table>
<p>操作：<code>Reg[rt] = Reg[rs] + Sign_Extend(immediate)</code></p>
<p>注意：该指令中的 u 表示寄存器为无符号的，是为了忽略溢出（和 C 语言的 <code>int</code>、<code>unsigned</code> 加法语义一致），立即数仍需符号位扩展。有一部分指令的立即数是 0 扩展。</p>
<hr />
<p><code>8d0c0000 lw t4,0(t0)</code></p>
<table><thead><tr><th>[31:26]:100011</th><th>[25:21]:01000</th><th>[20:16]:01100</th><th>[15:0]:0000_0000_0000_0000</th></tr></thead><tbody>
<tr><td>指令类型：LW</td><td>base: t0</td><td>rt: t4</td><td>offset</td></tr>
</tbody></table>
<p>操作：</p>
<ul>
<li><code>vaddr ← Reg[base] + Sign_Extend(offset)</code></li>
<li><code>if (vaddr[1:0] != 2'b0) Exception(Address Exception)</code>（本实验中，可以保证 <code>vaddr</code> 是 4 字节对齐）</li>
<li><code>Reg[rt] ← LoadMemory(AddressTranslation(vaddr), size = WORD)</code></li>
</ul>
<hr />
<p><code>pc = bfc00704:  	0ff00f00		jal	bfc03c00 &lt;n1_lui_test&gt;</code></p>
<table><thead><tr><th>[31:26]:000011</th><th>[25:0]:11_1111_0000_0000_1111_0000_0000</th></tr></thead><tbody>
<tr><td>指令类型：JAL（jump and link）</td><td>instr_index</td></tr>
</tbody></table>
<p>操作：</p>
<ul>
<li><code>Reg[31] ← pc + 8</code></li>
<li>执行下一条指令时：<code>pc ← {pc[31:28], instr_index, 2'b00}</code></li>
</ul>
<p>JAL 指令常用于函数调用。</p>
<pre><code class="language-mips"># note: in MIPS, branch-type instructions (including j, beq) have a delay slot.

sample1:
beq zero, zero, here # branch if equal
instruction1
instruction2

here:
instruction3

# sequence is: beq -&gt; instruction1 -&gt; instruction3


sample2:
bne zero, zero, there # branch if not equal
instruction 4
instruction 5
instruction 6

there:
instruction 7

# sequence is: bne -&gt; instruction 4 -&gt; instruction 5
</code></pre>
<p>本实验需要实现的指令：<code>lui</code>、<code>addu</code>、<code>addiu</code>、<code>beq</code>、<code>bne</code>、<code>lw</code>、<code>or</code>、<code>slt</code>、<code>slti</code>、<code>sltiu</code>、<code>sll</code>、<code>sw</code>、<code>j</code>、<code>jal</code>、<code>jr</code>、<del><code>addi</code></del>、<code>subu</code>、<code>sltu</code>、<code>and</code>、<code>andi</code>、<code>nor</code>、<code>ori</code>、<code>xor</code>、<code>xori</code>、<code>sra</code>、<code>srl</code>、<del><code>jalr</code></del>。</p>
<h3 id="112-虚实地址转换"><a class="header" href="#112-虚实地址转换">1.1.2 虚实地址转换</a></h3>
<p>指令代码、寄存器中的地址都是虚拟地址。CPU 向内存请求时，需要提供物理地址。</p>
<p>本实验中，只要求实现简单的虚实地址转换。</p>
<pre><code class="language-verilog">typedef logic [31:0] paddr_t;
typedef logic [31:0] vaddr_t;

paddr_t paddr; // physical address
vaddr_t vaddr; // virtual address

assign paddr[27:0] = vaddr[27:0];
always_comb begin
    unique case (vaddr[31:28])
        4'h8: paddr[31:28] = 4'b0; // kseg0
        4'h9: paddr[31:28] = 4'b1; // kseg0
        4'ha: paddr[31:28] = 4'b0; // kseg1
        4'hb: paddr[31:28] = 4'b1; // kseg1
        default: paddr[31:28] = vaddr[31:28]; // useg, ksseg, kseg3
    endcase
end
</code></pre>
<p>亦可以参考 RefCPU 中模块 <code>AddressTranslator</code> 的实现。</p>
<p>例如，当指令访问地址 <code>0xbfc00380</code> 时，实际访问的物理地址应该是 <code>0x1fc00380</code>。详见 <a href="../misc/external.html#mips-%E6%9E%B6%E6%9E%84">MIPS 手册 Ⅲ</a>：<i class="fa fa-file-pdf-o"></i> Volume III: MIPS32 Privileged Resource Architecture，第 29 页。</p>
<h2 id="12-五级流水线"><a class="header" href="#12-五级流水线">1.2 五级流水线</a></h2>
<p>五级流水线的简单示意图如下：</p>
<p><img src="../asset/lab1/5-stage.png" alt="5-stage" /></p>
<p>虚线上方为内存部分的硬件，由测试文件提供。</p>
<p>写 CPU，就是实现 CPU 的内部，并用事先定好的接口进行封装。</p>
<h3 id="121-select-pc"><a class="header" href="#121-select-pc">1.2.1 Select PC</a></h3>
<p>这一阶段在 Fetch Pipeline Register 前，选择流水线所执行的下一条指令的 PC。</p>
<p>可能的来源：</p>
<ul>
<li>顺序的下一条指令（PC + 4）</li>
<li>jump 类指令（<code>{pc[31:28], instr_index, 2'b00}</code>）</li>
</ul>
<p>等等。</p>
<h3 id="122-fetch"><a class="header" href="#122-fetch">1.2.2 Fetch</a></h3>
<p>向 Instruction Memory 提供指令地址，并接收指令。</p>
<p>注意：本实验中，内存有 1 周期的固定延迟。</p>
<p>其行为类似于：</p>
<pre><code class="language-verilog">logic [127:0][31:0] memory;
logic [6:0] addr;
logic [31:0] data;
always_ff @(posedge clk) begin
    data &lt;= memory[addr];
end
</code></pre>
<p>可考虑把接受的数据直接接到下一流水段。</p>
<h3 id="123-decode"><a class="header" href="#123-decode">1.2.3 Decode</a></h3>
<p>D 阶段完成：</p>
<ul>
<li>指令解码，生成控制信号</li>
<li>从 Regfile（寄存器文件堆）中读取数据</li>
<li>判断是否跳转</li>
</ul>
<h3 id="124-execute"><a class="header" href="#124-execute">1.2.4 Execute</a></h3>
<p>E 阶段主要为 ALU。</p>
<h3 id="125-memory"><a class="header" href="#125-memory">1.2.5 Memory</a></h3>
<p>M 阶段向 Data Memory 提供数据地址，并接收数据。</p>
<p>注意：本实验中，内存有 1 周期固定延迟。</p>
<h3 id="126-writeback"><a class="header" href="#126-writeback">1.2.6 Writeback</a></h3>
<p>W 阶段向 Regfile 写数据。</p>
<h3 id="127-regfile"><a class="header" href="#127-regfile">1.2.7 Regfile</a></h3>
<p>根据 MIPS 指令集架构，每条指令最多写 1 个通用寄存器，最多读 2 个通用寄存器。所以 Regfile 应设计为 1 个写端口，2 个读端口。</p>
<p>参考代码：</p>
<pre><code class="language-verilog">typedef logic[31:0] word_t;
typedef logic[4:0] creg_addr_t;

module regfile(
	input logic clk,
    input creg_addr_t ra1, ra2, wa3,
    input logic write_enable,
    input word_t wd3
    output word_t rd1, rd2
);
    word_t [31:1] regs, regs_nxt;

    // write: sequential logic
    always_ff @(posedge clk) begin
        regs[31:1] &lt;= regs_nxt[31:1];
    end
    for (genvar i = 1; i &lt;= 31; i ++) begin
        always_comb begin
            regs_nxt[i[4:0]] = regs[i[4:0]];
            if (wa3 == i[4:0] &amp;&amp; write_enable) begin
                regs_nxt[i[4:0]] = wd3;
            end
        end
    end


    // read: combinational logic
    assign rd1 = (ra1 == 5'b0) ? '0 : regs[ra1]; // or regs_nxt[ra1] ?
    assign rd2 = (ra2 == 5'b0) ? '0 : regs[ra2];

endmodule
</code></pre>
<h3 id="128-pipeline-register"><a class="header" href="#128-pipeline-register">1.2.8 Pipeline register</a></h3>
<p>五级流水线中，会有阻塞与气泡，所以流水线寄存器需要提供这些机制。</p>
<p>参考代码：</p>
<pre><code class="language-verilog">typedef struct packed {
    logic a;
} fetch_data_t;

module dreg (
	input logic clk, resetn,
    input fetch_data_t dataF_new,
    input logic enable, flush,
    output fetch_data_t dataF
);
    always_ff @(posedge clk) begin
        if (~resetn | flush) begin // flush overrides enable
            dataF &lt;= '0;
        end else if (enable) begin
            dataF &lt;= dataF_new;
        end
    end
endmodule
</code></pre>
<p>Tips：</p>
<ul>
<li>W 阶段流水线寄存器不允许被阻塞。</li>
<li>F 阶段流水线寄存器一般不清零；<strong>PC的复位值为 <code>32'hbfc0_0000</code></strong>。</li>
<li>M 阶段流水线寄存器阻塞时（因），E 阶段流水线寄存器通常也阻塞（果），防止丢失指令。</li>
<li>E 阶段流水线寄存器阻塞时（因），M 阶段流水线寄存器通常清零（果），防止指令被执行多次。</li>
</ul>
<h3 id="129-hazard-and-forward"><a class="header" href="#129-hazard-and-forward">1.2.9 Hazard and Forward</a></h3>
<p>这个部分代码量可能不大，但应该是本实验中最复杂的部分。</p>
<p>主要难点是数据冲突。本实验中，仅需考虑写后读（RAW）冲突。请思考：</p>
<ul>
<li>冲突阻塞部分：D 阶段取数据，E、M、W 阶段的写数据会造成冲突。哪些情况应当阻塞流水线？</li>
<li>转发部分：哪些指令写通用寄存器？电路图中的哪些数据线可作为转发来源？转发条件是什么？优先级是什么？</li>
</ul>
<p>分支预测失败的情况比较简单。D 阶段判断分支是否跳转；由于 delay slot 的设计，F 阶段的指令一定执行。所以，分支跳转不会有额外的惩罚（数据冲突可能存在）。</p>
<h3 id="1210-封装-cpu"><a class="header" href="#1210-封装-cpu">1.2.10 封装 CPU</a></h3>
<p>本实验的 CPU 的最顶层封装为 SRAM 接口。见 <code>source/mycpu/mycpu_top.sv</code>。</p>
<pre><code class="language-verilog">module mycpu_top (
    input logic clk,
    input logic resetn,  // low active
    input logic[5:0] ext_int,  // interrupt, high active

    output logic inst_sram_en,              // 指令内存总使能
    output logic[3:0] inst_sram_wen,        // 字节写使能，本实验中为全 0
    output logic[31:0] inst_sram_addr,      // 地址
    output logic[31:0] inst_sram_wdata,     // 写数据
    input logic[31:0] inst_sram_rdata,      // 读数据

    output logic data_sram_en,              // 数据内存总使能
    output logic[3:0] data_sram_wen,        // 字节写使能，本实验中为全 0 或全 1
    output logic[31:0] data_sram_addr,      // 地址
    output logic[31:0] data_sram_wdata,     // 写数据
    input logic[31:0] data_sram_rdata,      // 读数据

    //debug
    output logic[31:0] debug_wb_pc,         // W 阶段 PC
    output logic[3:0] debug_wb_rf_wen,      // 写使能，一般为全 0 或全 1
    output logic[4:0] debug_wb_rf_wnum,     // 写入的寄存器
    output logic[31:0] debug_wb_rf_wdata    // 写回的数据
);
    // TODO: other circuit

endmodule
</code></pre>
<p>为了保证和后续实验在接口上的统一，我们在 CPU 内部统一使用 DBus 接口。在 <code>source/mycpu/SRAMTop.sv</code> 做了从 DBus 接口到类 SRAM 接口的转换。DBus 接口定义在 <code>source/include/common.svh</code> 中：</p>
<pre><code class="language-verilog">typedef struct packed {
    logic    valid;   // 是否有请求？
    addr_t   addr;    // 请求读写的地址
    msize_t  size;    // 读写数据的大小：1、2 或者 4 字节，分别对应 MSIZE1、MSIZE2 和 MSIZE4
    strobe_t strobe;  // 4 位的字节写使能信号
    word_t   data;    // 如果写使能不为全 0，这里放写入的数据
} dbus_req_t;

typedef struct packed {
    logic  addr_ok;  // 内存是否已经接收了地址？
    logic  data_ok;  // 内存是否完成了访存？
    word_t data;     // 请求地址处读出的数据
} dbus_resp_t;
</code></pre>
<p>对于本次实验，因为访存是固定延时，并且所有读写的数据以及指令访存都是 4 字节的，所以</p>
<ul>
<li><code>dbus_resp_t</code> 中的 <code>addr_ok</code> 和 <code>data_ok</code> 信号实际上可以忽略。</li>
<li><code>addr</code> 最低两位应该始终为 0，即地址与 4 字节对齐。</li>
<li><code>size</code> 始终为 <code>MSIZE4</code>。</li>
<li>写操作时 <code>strobe</code> 为 <code>4'b1111</code> 或 <code>4'hf</code>。</li>
</ul>
<p>你可能会注意到还有一个 IBus 接口。IBus 接口是 DBus 接口的子集，只保留了读取数据所需要的信号。此外，你的流水线部分的顶层模块文件应该是 <code>source/mycpu/MyCore.sv</code>。我们建议你将你的流水线分为多个模块来实现。你可以在 <code>source/mycpu</code> 这个目录下新建文件或者子目录。</p>
<p>你可以选择在模块 <code>SRAMTop</code> 中做地址翻译，或是在模块 <code>MyCore</code> 中做地址翻译。</p>
<h3 id="1211-连接-debug_-信号"><a class="header" href="#1211-连接-debug_-信号">1.2.11 连接 <code>debug_*</code> 信号</a></h3>
<p>龙芯杯的测试会进行 trace 的比对。这需要从你的流水线中读取一些数据。我们在 1.2.10 一节中已经看到 <code>mycpu_top</code> 最后有四个 <code>debug_*</code> 信号了。为了避免增加下层模块的接口，我们建议你使用跨模块引用来连接这些 <code>debug_*</code> 信号。例如：</p>
<pre><code class="language-verilog">// in mycpu_top.sv
assign debug_wb_pc     = top.core.writeback.pc;
assign debug_wb_rf_wen = top.core.writeback.aha ? 4'b1111 : 4'b0;
</code></pre>
<h2 id="13-数据通路与译码控制信号"><a class="header" href="#13-数据通路与译码控制信号">1.3 数据通路与译码控制信号</a></h2>
<p>CPU 需要一系列硬件来执行指令所要求的功能。如果 CPU 只支持一条指令，那么 CPU 内所有的硬件都只为这一个功能所服务。随着指令条数的增加， CPU 设计者会添加一些硬件，同时也会复用一些原有的硬件。随着这些硬件复用性的提升， CPU 的数据通路会变得更复杂。Decode 阶段的译码器为这些硬件提供控制信号，这些控制信号也是高度复用的。</p>
<p>我们设计的第一条指令是 <code>addu</code>。只支持这一条指令的流水线，是比较简单的：</p>
<p><img src="../asset/lab1/datapath/addu.svg" alt="addu" /></p>
<p>随后，我们加入了 <code>addiu</code>。Execute 阶段的加法器可以被复用，但源操作数不再是两个寄存器的值，而是一个寄存器和一个立即数；目的寄存器也不再是 <code>rd</code>， 而是 <code>rt</code>：</p>
<p><img src="../asset/lab1/datapath/addiu.svg" alt="addiu" /></p>
<p><code>lw</code> 指令通过一个加法器算出数据的虚拟地址，这个加法器可以使用已有的加法器。然而，写入寄存器的数据不再是加法器，而是数据内存：</p>
<p><img src="../asset/lab1/datapath/sw.svg" alt="sw" /></p>
<p>添加了 <code>jal</code> 指令后，下一条指令的 PC 不再只可能是 (PC + 4)；写入的寄存器被指定为 31 号寄存器，数据则是指定为 (PC + 8)：</p>
<p><img src="../asset/lab1/datapath/jal.svg" alt="jal" /></p>
<p>当 CPU 需要支持新的指令时，根据该指令的功能，设计数据通路，并视具体情形添加或复用硬件与控制信号。添加硬件，会增加 CPU 的电路面积；复用原有硬件，会增加复用器的电路复杂性，增加电路延迟。</p>
<p>添加新硬件时，需考虑将该硬件放在流水线的哪一阶段，避免影响该流水段的逻辑延迟。</p>
<h2 id="14-流水线性能评估"><a class="header" href="#14-流水线性能评估">1.4 *流水线性能评估</a></h2>
<p>在本次实验中，我们实现了五级流水线 CPU。相对于单周期 CPU，流水线 CPU 牺牲了一些 IPC（流水线的数据冲突会阻塞流水线），换取频率的大幅提升。这一节主要分析流水线的性能。</p>
<h3 id="141-高延迟的逻辑部件"><a class="header" href="#141-高延迟的逻辑部件">1.4.1 高延迟的逻辑部件</a></h3>
<p>在本实验设计的 CPU 中，有以下几个高延迟的逻辑部件：</p>
<p><strong>寄存器文件</strong>：它的读逻辑和写逻辑都十分复杂。读过程的每一位是一个 32 选 1 的复用器，也就是 37 个变量的组合逻辑方程；读数据为 32 位，相当于上述逻辑复制 32 份。1 位寄存器的写逻辑比较简单，但 32 位的写入需要将该逻辑复制 32 次，电路就变得复杂了。</p>
<p><strong>算术逻辑单元 ALU</strong>：本实验需要实现的算数操作中，加法、比较运算的电路是级联，移位运算的电路是复用器；整个 ALU 的输出还需要一次复用。</p>
<p><strong>内存</strong>：本实验中不需要实现内存，但它在 CPU 的外部，数据传进来有很高的接线延迟。</p>
<h3 id="142-用转发来减少阻塞"><a class="header" href="#142-用转发来减少阻塞">1.4.2 用转发来减少阻塞</a></h3>
<p>在流水线中，写后读冲突会导致流水线阻塞。</p>
<p>如果需要的寄存器数据，在流水线的其他阶段已经计算好了，可以进行转发。</p>
<p>然而，转发会导致该阶段延迟的增加。下图的转发会大幅度增加 E 阶段的延迟：</p>
<p><img src="../asset/lab1/forward.svg" alt="forward" /></p>
<h3 id="143-pipeline-as-mechanism"><a class="header" href="#143-pipeline-as-mechanism">1.4.3 Pipeline as Mechanism</a></h3>
<p>单周期 CPU 中，时钟频率是不可控的：为了支持新的指令，需要向数据通路中添加新的逻辑部件，导致延迟将越来越高。</p>
<p>流水线是拆分数据通路的一种<strong>机制</strong>，它将各个高延迟的逻辑部件划分在不同的流水段，使得电路延迟变得<strong>可控</strong>。五级流水线是一种<strong>策略</strong>。根据现有的数据通路和频率要求，设计更深或更浅的流水线。</p>
<h2 id="15-发布包"><a class="header" href="#15-发布包">1.5 发布包</a></h2>
<p>用 Vivado 2019.2 打开 <code>vivado/test1_naive/soc_sram_func/run_vivado/mycpu_prj1/mycpu.xpr</code>，添加源文件后，即可开始仿真。</p>
<p>Tips：第一次仿真前，先点击 “IP Sources”，选中所有 IP 核源文件，右键，点击 “Generate Output Products”。几秒钟后，跳出 “OK”，然后再点仿真。</p>
<p><code>vivado/test1_naive/soft/obj/test.s</code> 是测试的反汇编文件，有 PC、机器码、汇编码的对应。<code>soft</code> 目录下的其他文件里，可以找到测试的 C 代码。</p>
<p><code>source/mycpu/</code> 里已经有一些代码，其中：</p>
<ul>
<li><code>mycpu_top.sv</code> 是顶层封装文件，仅需把 debug 信号连接上。</li>
<li><code>SRAMTop.sv</code> 是 SRAM 接口封装文件，需要添加虚实地址翻译。</li>
<li><code>MyCore.sv</code> 是 CPU 主体流水线文件。</li>
</ul>
<p>你可以在该目录下随意添加源文件。在 Vivado 中执行 <code>add_sources.tcl</code> 后，它们都会添加到项目里。</p>
<p><code>source/include/</code> 里有一些头文件。</p>
<p><strong>本次实验没有暂时没有使用 Verilator 进行仿真</strong>。我们会从实验 2 开始引入 Verilator，所以你需要确保你的在这次实验中编写的代码能够通过 Verilator 的编译。如果在使用 Verilator 中遇到了问题，请先阅读 <a href="../misc/verilate.html">Verilator 仿真</a>寻找解决方案。</p>
<h2 id="16-作业与提交"><a class="header" href="#16-作业与提交">1.6 作业与提交</a></h2>
<p>在 <code>source/mycpu/</code> 里添加你的代码，实现五级流水线 MIPS CPU。</p>
<p>本实验需要实现的指令：<code>lui</code>、<code>addu</code>、<code>addiu</code>、<code>beq</code>、<code>bne</code>、<code>lw</code>、<code>or</code>、<code>slt</code>、<code>slti</code>、<code>sltiu</code>、<code>sll</code>、<code>sw</code>、<code>j</code>、<code>jal</code>、<code>jr</code>、<del><code>addi</code></del>、<code>subu</code>、<code>sltu</code>、<code>and</code>、<code>andi</code>、<code>nor</code>、<code>ori</code>、<code>xor</code>、<code>xori</code>、<code>sra</code>、<code>srl</code>、<del><code>jalr</code></del>。</p>
<p><strong>PC的复位值为 <code>32'hbfc0_0000</code></strong>。</p>
<h3 id="161-通过标准"><a class="header" href="#161-通过标准">1.6.1 通过标准</a></h3>
<ol>
<li>打开原有 <code>mycpu.xpr</code>，用 <code>source/mycpu/add_sources.tcl</code> 添加源文件，上板显示两个绿灯。</li>
<li>在仓库根目录打开终端，运行 <code>make verilate TARGET=mycpu/VTop</code>，确认 Verilator 能够编译你的 CPU 代码，并且没有报告任何错误和警告。</li>
</ol>
<h3 id="162-实验报告要求"><a class="header" href="#162-实验报告要求">1.6.2 实验报告要求</a></h3>
<ul>
<li>格式：PDF</li>
<li>内容：按本文档 1.2 节的思路写即可。写好姓名学号。</li>
</ul>
<h3 id="163-提交文件格式"><a class="header" href="#163-提交文件格式">1.6.3 提交文件格式</a></h3>
<pre><code class="language-plaintext">18307130024/
├── report/（报告所在目录）
└── source/（源文件所在目录）
</code></pre>
<p>用 <code>zip -r 18307130024.zip 18307130024/</code> 打包。用 <code>unzip 18307130024.zip</code> 检查，应在当前目录下有学号目录。</p>
<h3 id="164-评分"><a class="header" href="#164-评分">1.6.4 评分</a></h3>
<p>代码 80%，报告 20%。</p>
<p><strong>Deadline：2021 年 3 月 21 日 23:59:59</strong></p>
<h2 id="17-思考"><a class="header" href="#17-思考">1.7 *思考</a></h2>
<ol>
<li>流水线寄存器的 flush 信号，需要让所有信号都清零吗？</li>
<li>转发的成本是什么？有哪些限制？（板子上的组合逻辑基本部件为 LUT6，6 输入 1 输出，可实现 6 输入的任何给定逻辑式）</li>
<li>不同指令需要用到的流水线阶段可能不同：加法指令似乎不需要经过 Memory 阶段。能让它跳过 M 阶段吗？</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../arch-lab/lab0.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../arch-lab/lab2a.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../arch-lab/lab0.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../arch-lab/lab2a.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
