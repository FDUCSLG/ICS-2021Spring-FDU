<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>实验 2a - Introduction to NSCSCC</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../schedule.html">课程安排</a></li><li class="chapter-item expanded "><a href="../arch-lab/index.html">体系结构部分</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../arch-lab/lab0.html">实验 0</a></li><li class="chapter-item "><a href="../arch-lab/lab1.html">实验 1</a></li><li class="chapter-item expanded "><a href="../arch-lab/lab2a.html" class="active">实验 2a</a></li><li class="chapter-item "><a href="../arch-lab/lab2b.html">实验 2b</a></li><li class="chapter-item "><a href="../arch-lab/lab3a.html">实验 3a</a></li><li class="chapter-item "><a href="../arch-lab/lab3b.html">实验 3b</a></li><li class="chapter-item "><a href="../arch-lab/lab4.html">实验 4</a></li></ol></li><li class="chapter-item expanded "><a href="../project/index.html">挑战课题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../project/task1.html">流水线</a></li><li class="chapter-item "><a href="../project/task2.html">缓存</a></li><li class="chapter-item "><a href="../project/task3.html">外设</a></li></ol></li><li class="chapter-item expanded "><a href="../misc/index.html">附加资料</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../misc/external.html">外部资料</a></li><li class="chapter-item "><a href="../misc/instruction.html">指令列表</a></li><li class="chapter-item "><a href="../misc/fpga.html">了解 FPGA 架构</a></li><li class="chapter-item "><a href="../misc/verilate.html">Verilator 仿真</a></li><li class="chapter-item "><a href="../misc/unopt.html">组合逻辑环与 UNOPT</a></li><li class="chapter-item "><a href="../misc/gtkwave.html">使用 GTKWave</a></li></ol></li><li class="chapter-item expanded "><a href="../directory-structure.html">仓库目录结构</a></li><li class="chapter-item expanded affix "><a href="../faq.html">常见问题</a></li><li class="chapter-item expanded affix "><a href="../contributors.html">贡献者</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Introduction to NSCSCC</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-2a总线仲裁与延时"><a class="header" href="#实验-2a总线仲裁与延时">实验 2a：总线仲裁与延时</a></h1>
<h2 id="仲裁"><a class="header" href="#仲裁">仲裁</a></h2>
<p>多个独立运行的实体同时访问共享资源时，往往需要通过仲裁决定访问的先后顺序。</p>
<p>在实验 1 中，CPU 有两套访存接口：一个用于取指，另一个用于读写数据。<code>test1_naive</code> 将指令内存和数据内存分开了，从而能够同时支持两边的访问。现实生活中的计算机架构一般遵循 von Neumann 架构，即指令和数据放在同一个内存中。此时需要内存有两个读写端口。</p>
<p>但是多端口的存储单元往往非常消耗资源（例如，6 端口寄存器文件）。现代的 CPU 的核心数量越来越多，提供多端口的存储单元非常不现实。此外，如果有两个或者更多的端口同时写入同一个位置时，我们需要规定谁的写入是有效的，此时发生了写入冲突。</p>
<p>解决这一问题的一种方法是仲裁，即当有多个实体同时访问同一个对象时，允许其中一个进行访问，要求其它的实体等待。这个过程类似于加锁互斥。</p>
<p><code>test1</code>~<code>test4</code> 的内存都只有一个端口，因此需要进行仲裁。</p>
<h2 id="延时"><a class="header" href="#延时">延时</a></h2>
<p>仲裁会导致等待，因此我们不能再期望数据会在固定的时间内返回。此外，现代 CPU 的主频和内存频率往往不同，并且 CPU 为了降低功耗通常会动态调频，因此增加了访存需要的周期数的不确定性。下表是 Intel 的 Skylake 架构中 cache 的各项参数，来自 “Intel 64 and IA-32 Architectures Optimization Reference Manual”：</p>
<p><img src="../asset/lab2/skylake-cache.png" alt="Skylake 的 cache 参数" /></p>
<p>可以看到各级缓存的访问所需要的周期数都是不一样的，并且都不是固定的。</p>
<h2 id="dbus"><a class="header" href="#dbus">DBus</a></h2>
<p>DBus 是一个单向握手协议，其定义在 <code>common.svh</code> 中：</p>
<pre><code class="language-verilog">typedef struct packed {
    logic    valid;   // in request?
    addr_t   addr;    // target address
    msize_t  size;    // number of bytes
    strobe_t strobe;  // which bytes are enabled? set to zeros for read request
    word_t   data;    // the data to write
} dbus_req_t;

typedef struct packed {
    logic  addr_ok;  // is the address accepted by cache?
    logic  data_ok;  // is the field &quot;data&quot; valid?
    word_t data;     // the data read from cache
} dbus_resp_t;
</code></pre>
<h3 id="总线握手"><a class="header" href="#总线握手">总线握手</a></h3>
<p>DBus 的逻辑是：由 CPU 主动发出请求（拉起 <code>valid</code> 信号），等待内存给出反馈（<code>addr_ok</code> 和 <code>data_ok</code>）。DBus 的反馈分为两个阶段，一是内存已经得知并且缓存了 CPU 的请求，此时内存会将 <code>addr_ok</code> 拉起；二是内存已经完成了 CPU 的请求，此时将 <code>data_ok</code> 拉起。这两个过程就是所谓的 “握手”。握手是一个时序逻辑。每当时钟周期上升沿触发时，如果 <code>addr_ok</code> 为 <code>1</code>，表明握手成功。<code>data_ok</code> 同理。例如，CPU 想写入内存，内存也支持单周期写入，此时内存会把 <code>addr_ok</code> 和 <code>data_ok</code> 同时设为 <code>1</code>。等到时钟上升沿到达时，内存就会触发写入，同时 CPU 也知道内存已经完成这个写入了。</p>
<p><img src="../asset/lab2/single-cycle.svg" alt="单周期访存" /></p>
<p>如果内存需要多个周期才能完成一次访存，CPU 需要一直拉起 <code>valid</code> 信号，直到内存的 <code>addr_ok</code> 响应。</p>
<p><img src="../asset/lab2/multi-cycle.svg" alt="多周期访存" /></p>
<p>访存有一个常见的优化是写缓冲区（store buffer）。写缓冲会保存收到的请求，发出 <code>addr_ok</code>，然后再进行真正的写内存操作。CPU 一般不用关心写操作是否真的完成了，因此流水线在收到 <code>addr_ok</code> 的时候就可以继续推进。这样可以明显减少写内存带来的流水线阻塞。</p>
<p><img src="../asset/lab2/store-buffer.svg" alt="写缓冲区优化" /></p>
<p>访存也可以切分流水线。CPU 的 fetch 阶段和 memory 阶段可以分为多个周期完成，此时需要 cache 也按照流水线的方式工作。这样即便单次访存的延时很高，cache 提供的吞吐率却不低。</p>
<p><img src="../asset/lab2/pipelined.svg" alt="流水线化访存" /></p>
<p>注意：CPU 收到 <code>addr_ok</code> 后，如果没有其它请求，必须把 <code>valid</code> 撤下。</p>
<h3 id="size-信号"><a class="header" href="#size-信号"><code>size</code> 信号</a></h3>
<p><code>size</code> 是一个枚举。DBus 支持 <code>MSIZE1</code>（单字节）、<code>MSIZE2</code>（双字节）和 <code>MSIZE4</code>（四字节）三种模式。</p>
<h3 id="byte-lanes"><a class="header" href="#byte-lanes">Byte Lanes</a></h3>
<p>DBus 是 32 位的总线，每周期至多传输 4 个字节。<code>data</code> 的四个字节可以视作四个独立的通道 <code>lane[3:0]</code>，<code>lane[0]</code> 对应地址最后两位为 <code>2'b00</code> 的那个字节，<code>lane[1]</code> 对应最后两位为 <code>2'b01</code> 的字节，依次类推。因此，无论我们给出的地址是否与 4 字节对齐，<code>data</code> 中的数据依然会按照 4 字节对齐的方式摆放。DBus 提供一个 4 位的写使能 <code>strobe[3:0]</code>，<code>strobe[0]</code> 表示 <code>lane[0]</code> 是否启用，<code>strobe[3..1]</code> 类似。通过这种方式，DBus 允许写入比 4 字节窄的数据。</p>
<p>例如，我们向地址 <code>0xbfc001f2</code> 写入单个字节的数据 <code>0xcd</code> 时，由于地址的最低两位为 <code>0x2</code>（<code>2'b10</code>），所以我们应该：</p>
<ul>
<li>地址 <code>addr</code> 依然是 <code>32'hbfc001f2</code>。</li>
<li>将 <code>data</code> 设置为 <code>32'h00cd0000</code>。</li>
<li>将 <code>strobe</code> 设置为 <code>4'b0100</code>。</li>
</ul>
<p>这么做可能比较反直觉。DBus 的 byte lanes 来源于 AXI 总线协议，其意图在于兼容只能 4 字节对齐寻址的设备（一般的内存都是这么做的），同时不要求 <code>addr</code> 必须与 4 字节对齐是因为可能会和只能字节寻址的设备交互（例如字符打印）。</p>
<p>换句话说，当你向 <code>0x1f2</code> 发送读取请求时，DBus 会把 <code>0x1f0</code>、<code>0x1f1</code>、<code>0x1f2</code> 和 <code>0x1f3</code> 这四个地址对应的字节全部返回给你，分别放在 <code>data[7:0]</code>、<code>data[15:8]</code>、<code>data[23:16]</code> 和 <code>data[31:24]</code> 中。同样的，当你向 <code>0x1f2</code> 这个地址写入时，实际上是同时向 <code>0x1f0</code>、<code>0x1f1</code>、<code>0x1f2</code> 和 <code>0x1f3</code> 这四个地址对应的字节写入，不过此时我们可以使用 <code>strobe</code> 信号单独决定每个字节是否真的需要写入。</p>
<p>下面展示了从地址 <code>0xbfc01fc2</code> 开始连续写入 15 个字节 <code>0x11</code>~<code>0xff</code> 的过程：</p>
<p><img src="../asset/lab2/byte-lanes.svg" alt="DBus 连续写入示例" /></p>
<h3 id="ibus"><a class="header" href="#ibus">IBus</a></h3>
<p>IBus 是 DBus 的子集，仅保留了读取 4 字节（<code>word_t</code>）的接口。</p>
<h2 id="实验内容"><a class="header" href="#实验内容">实验内容</a></h2>
<p>下面将分步骤介绍本实验要完成的内容。</p>
<h3 id="支持总线延时"><a class="header" href="#支持总线延时">支持总线延时</a></h3>
<p>在 <code>mycpu_top.sv</code> 的开头，有一个宏 <code>FIXED_LATENCY</code> 确定该模块使用类 SRAM 接口还是 AXI 接口：</p>
<pre><code class="language-verilog">/**
 * TODO (Lab2) comment out the following line :)
 */
`define FIXED_LATENCY

module mycpu_top (
`ifdef FIXED_LATENCY
    // ...
</code></pre>
<p>本次实验你需要将这一行 <code>define</code> 注释掉。之后</p>
<ul>
<li><code>mycpu_top</code> 会使用 AXI 接口。</li>
<li>仿真的顶层模块从 <code>SRAMTop</code> 变成 <code>VTop</code>。
<ul>
<li>如果你上一次实验的地址翻译放在 <code>SRAMTop</code>，你可能需要将它们迁移到 <code>VTop</code>。</li>
</ul>
</li>
</ul>
<p>这里只修改了 <code>mycpu_top</code> 的接口，<code>MyCore</code> 依然使用 DBus/IBus。你不需要关心 AXI 接口是如何操作的。如果你感兴趣，可以自行阅读 <code>util</code> 文件夹下的 <code>CBusToAXI.sv</code>。</p>
<p>你需要修改流水线寄存器的阻塞逻辑。一条 <code>lw</code> 指令在 memory 阶段发出访存请求，在数据返回前，显然需要阻塞流水线。</p>
<p>一个简单的改动如下：</p>
<pre><code class="language-verilog">assign stallF = ~i_data_ok | ~d_data_ok;
assign stallD = ~i_data_ok | ~d_data_ok;
assign stallE = ~d_data_ok;
assign stallM = ~d_data_ok;
assign flushE = ~i_data_ok;
assign flushW = ~d_data_ok;
</code></pre>
<p>注意：这个处理的性能未必好，内存的写请求不一定需要进行 <code>data_ok</code> 的握手。</p>
<p>完成后，你应该能够通过 <code>vivado/test1</code> 的测试。</p>
<h3 id="实现仲裁器"><a class="header" href="#实现仲裁器">*实现仲裁器</a></h3>
<p>我们已经提供了一个简单的仲裁器实现，在 <code>source/util/CBusArbiter.sv</code> 中。<code>VTop</code> 默认使用 <code>CBusArbiter</code>：</p>
<pre><code class="language-verilog">    /**
     * TODO (Lab2) replace mux with your own arbiter :)
     */
    CBusArbiter mux(
        .ireqs({icreq, dcreq}),
        .iresps({icresp, dcresp}),
        .*
    );
</code></pre>
<p><code>CBusArbiter</code> 有一个缺点，它需要花费一个时钟周期来确定谁有总线的访问权，无论是有多个请求还是只有一个请求。换句话说，<code>CBusArbiter</code> 会把所有的访存增加至少一个周期的延时。实际上这一个时钟周期可以被优化掉，只是这么做是要付出代价的。因为这种优化需要添加新的组合逻辑，有可能会增加关键路径的延时，导致 CPU 频率降低。</p>
<p>如果你想优化 <code>CBusArbiter</code>，请在 <code>source/mycpu/MyArbiter.sv</code> 中实现新的仲裁器，然后将 <code>VTop</code> 的 <code>CBusArbiter mux</code> 换成 <code>MyArbiter mux</code>。</p>
<p>另外请注意：<strong><code>CBusArbiter</code> 默认的仲裁策略是 DBus 比 IBus 优先</strong>。如果你想调换优先级，请将上面 <code>CBusArbiter mux</code> 接口中的 <code>icreq</code> 和 <code>dcreq</code> 对换，以及将 <code>icresp</code> 和 <code>dcresp</code> 对换。</p>
<h3 id="实现新的指令"><a class="header" href="#实现新的指令">实现新的指令</a></h3>
<p><a href="../misc/instruction.html">“指令列表”</a> 中有一张表，记录了 <code>test1</code> 到 <code>test4</code> 和所有性能测试会用到的指令。请据此确定 <code>test2</code> 需要添加的指令并实现。</p>
<p><code>test2</code> 中需要额外实现的指令，主要有以下三类：</p>
<ul>
<li>更多种类的分支跳转。</li>
<li>引入了以半字（16 位）和字节（8 位）为粒度的内存读写。
<ul>
<li>注意调整总线请求的 <code>size</code> 部分，以及处理读写的数据。</li>
</ul>
</li>
<li>移位的偏移量为寄存器数据。</li>
</ul>
<h3 id="接入-verilator"><a class="header" href="#接入-verilator">接入 Verilator</a></h3>
<p>下一轮实验会使用 Verilator 做模块级测试。本次实验先用 <code>test1</code> 和 <code>test2</code>，方便大家熟悉 Verilator 仿真的流程。</p>
<p>我们提供的测试框架里面，Vivado 仿真的顶层是 <code>mycpu_top</code>，而 Verilator 仿真的顶层用的通常是字母 <code>V</code> 开头的模块<sup class="footnote-reference"><a href="#vtop">1</a></sup>（如 <code>VTop</code>、<code>VCacheTop</code>）。每一个顶层模块对应一个目标名称，也就是 <code>make vsim</code> 命令的 <code>TARGET</code> 参数。如果想以 <code>source/mycpu/VTop.sv</code> 这个文件作为顶层模块，其对应的 <code>TARGET</code> 就是 <code>mycpu/VTop</code>。</p>
<p>测试框架的代码放在 <code>verilate/source</code> 和 <code>verilate/include</code> 两个目录下。不同的顶层模块可能需要不同的测试代码，这些代码会分别放在 <code>verilate/source</code> 中对应子目录里面。如果 <code>TARGET</code> 是 <code>mycpu/VTop</code>，那么其专用的测试代码都放在 <code>verilate/source/mycpu/VTop</code> 下。我们提供了大部分 <code>mycpu/VTop</code> 的测试代码，目前这个目录下有：</p>
<ul>
<li><code>defs.h</code>：一些类型定义。</li>
<li><code>mycpu.h</code>：verilated 模型类的声明。</li>
<li><code>mycpu.cpp</code>：verilated 模型类的实现。</li>
<li><code>vmain.cpp</code>：仿真程序 <code>vmain</code> 的程序入口的代码。</li>
</ul>
<p>所谓 verilated 模型是指把 SystemVerilog 描述的模块翻译成 C++ 代码后的一个 <code>class</code>。翻译后的 verilated 模型再和测试框架一起编译成可执行文件 <code>vmain</code> 后，运行 <code>vmain</code> 就会开始正式的仿真。</p>
<p>运行龙芯杯的 <code>test1</code> 和 <code>test2</code> 需要支持 trace 比对。你需要将 <code>debug_*</code> 信号暴露给 verilated 模型。以 writeback 阶段的 PC 为例，假设某个 CPU 结构如下面的代码所示：</p>
<pre><code class="language-verilog">module Writeback;
    logic [31:0] pc;
endmodule

module MyCore;
    Writeback wb;
endmodule

module VTop;
    MyCore core;
endmodule
</code></pre>
<p>当 <code>VTop</code> 是顶层模块时，从 <code>VTop</code> 访问 PC 的跨模块引用应该写成 <code>core.wb.pc</code>。为了能在 Verilator 中访问到这个信号，首先你需要将 <code>pc</code> 声明为公开的：</p>
<pre><code class="language-verilog">module Writeback;
    logic [31:0] pc /* verilator public_flat_rd */;
endmodule
</code></pre>
<p><code>/* verilator public_flat_rd */</code> 是一条 metacomment。其中 <code>public</code> 表示信号对外可访问，<code>flat</code> 表示信号名会被去层次化（flatten），<code>rd</code> 表示只读（read-only）。去层次化意思是 <code>core.wb.pc</code> 这个信号在翻译后的 C++ 代码中会以一个普通变量的方式呈现给 verilated 模型。C/C++ 的变量名里面不能有 “<code>.</code>”，因此 Verilator 会把 <code>core.wb.pc</code> 转换成 <code>core__DOT__wb__DOT__pc</code>。之后你需要修改 <code>verilate/source/mycpu/VTop</code> 文件夹中的 <code>mycpu.cpp</code>：</p>
<pre><code class="language-c++">auto MyCPU::get_writeback_pc() const -&gt; addr_t {
    /**
     * TODO (Lab2) retrieve PC from verilated model :)
     */
    return VTop-&gt;core__DOT__wb__DOT__pc;  // 访问 PC
}
</code></pre>
<p>这里 <code>VTop</code> 是指向顶层模块的作用域（scope）的指针，由 Verilator 自动生成。用 <code>VTop</code> 可以访问到先前模块内部公开的信号。当 C++ 代码调用上面这个函数时，就会返回当前 <code>core.wb.pc</code> 的值<sup class="footnote-reference"><a href="#pc-type">2</a></sup>。你还需要实现另外 3 个类似的函数。</p>
<p>之后在仓库根目录下运行：</p>
<pre><code class="language-shell">make vsim TARGET=mycpu/VTop TEST=test1 -j
</code></pre>
<p>将会运行 <code>test1</code>。把 <code>TEST=test1</code> 换成 <code>TEST=test2</code> 就会运行 <code>test2</code>。<code>test1</code> 会输出以下内容：</p>
<pre><code class="language-plaintext">./build/gcc/mycpu/VTop/vmain -m misc/nscscc/test1.coe -r misc/nscscc/test1.txt
(info) #1 completed.
(info) #2 completed.
(info) #3 completed.
(info) #4 completed.
(info) #5 completed.
(info) #6 completed.
(info) #7 completed.
(info) #8 completed.
(info) #9 completed.
(info) #10 completed.
(info) #11 completed.
(info) #12 completed.
(info) #13 completed.
(info) #14 completed.
(info) #15 completed.
(info) #16 completed.
(info) #17 completed.
(info) #18 completed.
(info) #19 completed.
(info) #20 completed.
(info) #21 completed.
(info) #22 completed.
(info) #23 completed.
(info) #24 completed.
(info) #25 completed.
(info) #26 completed.
(info) #27 completed.
(info) testbench finished in 337516 cycles (601.973 KHz).
</code></pre>
<h3 id="随机延时"><a class="header" href="#随机延时">随机延时</a></h3>
<p><code>vmain</code> 默认情况下并没有随机延时。可以使用 <code>--p-disable</code>/<code>-p</code> 参数开启随机延时。这个参数是一个概率值，表示内存每个周期无响应的概率。例如：</p>
<pre><code class="language-shell">make vsim -j TARGET=mycpu/VTop TEST=test1 VSIM_ARGS='-p 0.99'
</code></pre>
<p>表示内存有 99% 的时间没有响应。如果设置为 <code>-p 0</code>，相当于关闭随机延时。</p>
<h3 id="记录波形图"><a class="header" href="#记录波形图">记录波形图</a></h3>
<p>如果你不幸没有通过 <code>vmain</code> 的测试，看到了类似于下面的报错：</p>
<pre><code class="language-plaintext">TextDiff: on line 18:
	expect: &quot;1 9fc03be0 10 00000001&quot;
	   got: &quot;1 9fc05100 10 00000001&quot;
make: *** [verilate/Makefile.vsim.mk:123: vsim] Aborted (core dumped)
</code></pre>
<p>这是 trace 比对出错。你可能需要使用波形图来调试。为了加速仿真，<code>make vsim</code> 默认不会记录波形图。使用 <code>--fst-trace</code>/<code>-f</code> 参数开启波形图记录并且指定波形图文件保存的位置。例如：</p>
<pre><code class="language-shell">make vsim TARGET=mycpu/VTop TEST=test1 -j VSIM_ARGS=&quot;-f build/trace.fst&quot;
</code></pre>
<p>将会把波形图保存到 <code>build</code> 目录下的 <code>trace.fst</code>。仿真成功运行或者中途失败退出时，会保存 FST 波形图，并且能在终端输出看到一行信息：</p>
<pre><code class="language-plaintext">FST trace: stop @558950
</code></pre>
<p>FST 格式的波形图文件需要用 GTKWave 打开：</p>
<pre><code class="language-shell">gtkwave build/trace.fst
</code></pre>
<p>你需要自行摸索 GTKWave 的使用方式。我们提供了一份简短的使用说明：<a href="../misc/gtkwave.html">“使用 GTKWave”</a>。</p>
<p>如果遇到你无法确定原因的错误，例如 assertion failed、segmentation fault 之类，有可能是测试框架的问题。请及时向助教反馈。如果遇到这些错误时，终端/命令行最后输出了 “<code>(core dumped)</code>”（上面 trace 比对出错的输出就有），说明这个错误可以使用 <code>coredumpctl gdb</code> 启动 GDB 查看。请进入 GDB 输入 <code>backtrace</code> 后回车，将调用栈打印出来，然后连同调用栈和错误信息一起反馈给助教。</p>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p>总结一下实验 2a 要做的事情：</p>
<ul>
<li>修改取指和访存阶段的逻辑，支持多周期访存。
<ul>
<li>在 Vivado 仿真中通过 <code>test1</code>。</li>
</ul>
</li>
<li>*在 <code>MyArbiter.sv</code> 中实现仲裁器。</li>
<li>根据 <a href="../misc/instruction.html">“指令列表”</a> 添加新的指令。
<ul>
<li>在 Vivado 仿真中通过 <code>test2</code>。</li>
</ul>
</li>
<li>修改 <code>verilate/source/mycpu/VTop</code> 下的 C++ 代码。
<ul>
<li>在 Verilator 仿真中通过 <code>test1</code> 和 <code>test2</code>。</li>
</ul>
</li>
<li>通过 <code>test1</code> 和 <code>test2</code> 上板测试。</li>
</ul>
<p>以上是我们推荐的完成顺序。</p>
<h2 id="实验提交"><a class="header" href="#实验提交">实验提交</a></h2>
<p><strong>本实验和实验 2b 一起提交。</strong></p>
<pre><code class="language-plaintext">18307130024/
├── report/   （报告所在目录）
├── source/   （源文件所在目录）
└── verilate/ （仿真代码所在目录）
</code></pre>
<p>用 <code>zip -r 18307130024.zip 18307130024/</code> 打包。用 <code>unzip 18307130024.zip</code> 检查，应在当前目录下有学号目录。</p>
<h3 id="通过标准"><a class="header" href="#通过标准">通过标准</a></h3>
<ul>
<li>通过以下四条命令的测试：
<ul>
<li><code>make vsim -j TARGET=mycpu/VTop TEST=test1</code></li>
<li><code>make vsim -j TARGET=mycpu/VTop TEST=test1 VSIM_ARGS=&quot;-p 0.99&quot;</code></li>
<li><code>make vsim -j TARGET=mycpu/VTop TEST=test2</code></li>
<li><code>make vsim -j TARGET=mycpu/VTop TEST=test2 VSIM_ARGS=&quot;-p 0.99&quot;</code></li>
</ul>
</li>
<li>上板通过 <code>test1</code> 和 <code>test2</code>。</li>
</ul>
<h3 id="实验报告要求"><a class="header" href="#实验报告要求">实验报告要求</a></h3>
<ul>
<li>格式：PDF</li>
<li>内容：简要记录你所做的修改。写好姓名学号。附上测试通过时的照片或截图。</li>
</ul>
<h3 id="截止时间"><a class="header" href="#截止时间">截止时间</a></h3>
<p><strong>2021 年 4 月 11 日 23:59:59</strong></p>
<h2 id="思考题"><a class="header" href="#思考题">*思考题</a></h2>
<ol>
<li>
<p>张三在 <code>source/util/CBusMultiplexer.sv</code> 中实现了自己的仲裁器，然而过不了仿真。请指出 <code>CBusMultiplexer</code> 存在的问题。</p>
</li>
<li>
<p>龙芯杯的测试框架中有一个叫做 CONFREG 的模块<sup class="footnote-reference"><a href="#confreg">3</a></sup>，用来控制 FPGA 上的各种硬件资源，例如 LED 数码管、按钮。CONFREG 是一个 memory-mapped 设备。其中地址 <code>0xbfaffff0</code> 是一个简化的 UART 打印接口，往这个地址写入 ASCII 码就可在仿真中输出文字。特别的，如果写入的值是 <code>0xff</code>，就会立即停止仿真。</p>
<p>李四写了一段汇编程序 <code>hello.s</code>，放在 <code>misc/hello</code> 目录下，它会打印 “Hello, world!”。但是李四买不起 CPU。请尝试将这段汇编代码编译成 <code>.coe</code> 文件，然后使用</p>
<pre><code class="language-shell">make vsim -j TARGET=mycpu/VTop VSIM_ARGS=&quot;-m [.coe 文件路径]&quot;
</code></pre>
<p>在你的 CPU 上运行这个程序。如果没有出错，<code>vmain</code> 最后会输出：</p>
<pre><code class="language-plaintext">./build/gcc/mycpu/VTop/vmain -m misc/hello/hello.coe
Hello, world!
(info) testbench finished in 652 cycles (515.101 KHz).
</code></pre>
<p>至此，你<del>李四</del>可以尝试在你的 CPU 上运行更加复杂的程序了。</p>
</li>
<li>
<p>王五最近学习了 AXI 总线协议。AXI 是一个双向握手协议。王五推荐你阅读 <a href="../misc/external.html#soc-%E9%83%A8%E5%88%86">“<i class="fa fa-file-pdf-o"></i> AMBA AXI Protocol Specification v1.0”</a>，希望你能了解并总结 AXI 总线的工作方式。</p>
</li>
</ol>
<hr />
<div class="footnote-definition" id="vtop"><sup class="footnote-definition-label">1</sup>
<p><code>VTop</code> 用的是将在实验 3a 中介绍的 CBus（cache bus），是 AXI 总线的简化。Verilator 仿真的顶层模块和 Vivado 中不同的原因之一就是 CBus 模拟起来简单一些 <code>:)</code></p>
</div>
<div class="footnote-definition" id="pc-type"><sup class="footnote-definition-label">2</sup>
<p>类型是 32 位的 <code>uint32_t</code>。</p>
</div>
<div class="footnote-definition" id="confreg"><sup class="footnote-definition-label">3</sup>
<p>我们猜测这是 “configuration registers” 的缩写。</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../arch-lab/lab1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../arch-lab/lab2b.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../arch-lab/lab1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../arch-lab/lab2b.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
