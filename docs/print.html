<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to NSCSCC</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="schedule.html">课程安排</a></li><li class="chapter-item expanded "><a href="arch-lab/index.html">体系结构部分</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="arch-lab/lab0.html">实验 0</a></li><li class="chapter-item "><a href="arch-lab/lab1.html">实验 1</a></li><li class="chapter-item "><a href="arch-lab/lab2a.html">实验 2a</a></li><li class="chapter-item "><a href="arch-lab/lab2b.html">实验 2b</a></li><li class="chapter-item "><a href="arch-lab/lab3a.html">实验 3a</a></li><li class="chapter-item "><a href="arch-lab/lab3b.html">实验 3b</a></li><li class="chapter-item "><a href="arch-lab/lab4.html">实验 4</a></li></ol></li><li class="chapter-item expanded "><a href="sys-lab/index.html">操作系统部分</a></li><li class="chapter-item expanded "><a href="project/index.html">挑战课题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="project/task1.html">流水线性能优化</a></li></ol></li><li class="chapter-item expanded "><a href="misc/index.html">附加资料</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="misc/external.html">外部资料</a></li><li class="chapter-item "><a href="misc/instruction.html">指令列表</a></li><li class="chapter-item "><a href="misc/fpga.html">了解 FPGA 架构</a></li><li class="chapter-item "><a href="misc/verilate.html">Verilator 仿真</a></li><li class="chapter-item "><a href="misc/unopt.html">组合逻辑环与 UNOPT</a></li><li class="chapter-item "><a href="misc/gtkwave.html">使用 GTKWave</a></li></ol></li><li class="chapter-item expanded "><a href="directory-structure.html">仓库目录结构</a></li><li class="chapter-item expanded affix "><a href="faq.html">常见问题</a></li><li class="chapter-item expanded affix "><a href="contributors.html">贡献者</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Introduction to NSCSCC</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<img src="asset/banner.svg" width=100% alt="Welcome!" />
<p>计算机系统基础（下）荣誉课程。2021 年春季。</p>
<ul>
<li>实验课时间：<i class="fa fa-calendar"></i> 每周一，15:25-17:05 p.m.</li>
<li>GitHub 仓库：<i class="fa fa-github"></i> <a href="https://github.com/FDUCSLG/ICS-2021Spring-FDU">FDUCSLG/ICS-2021Spring-FDU</a></li>
<li>课程首页：<i class="fa fa-link"></i> <a href="https://fducslg.github.io/ICS-2021Spring-FDU/">https://fducslg.github.io/ICS-2021Spring-FDU/</a></li>
<li>答疑平台：<i class="fa fa-slack"></i> <a href="https://fducslg.slack.com">FDUCSLG Slack</a>，#sig-architecture</li>
<li><i class="fa fa-question-circle"></i> <a href="faq.html">常见问题</a> / <i class="fa fa-book"></i> <a href="misc/external.html">外部资料</a> / <i class="fa fa-folder-open"></i> <a href="directory-structure.html">仓库结构</a> / <i class="fa fa-user"></i> <a href="contributors.html">贡献者</a></li>
</ul>
<p>实验课程安排：</p>
<table class="schedule-table">
  <thead>
    <tr>
      <th align="center">日期</th>
      <th align="center">实验课安排</th>
      <th align="center">日期</th>
      <th align="center">实验课安排</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">3.1</td>
      <td align="center">
        <a href="arch-lab/lab0.html">布置实验 0</a><br>
        <a href="arch-lab/lab1.html">布置实验 1</a>
      </td>
      <td align="center">4.26</td>
      <td align="center">
        <a href="arch-lab/lab4.html">布置实验 4</a>
      </td>
    </tr>
    <tr>
      <td align="center">3.8</td>
      <td align="center">
        <span class="red">实验 0 结束</span>
      </td>
      <td align="center">5.3</td>
      <td align="center">
        <span class="green">五一劳动节</span>
      </td>
    </tr>
    <tr>
      <td align="center">3.15</td>
      <td align="center">
      </td>
      <td align="center">5.10</td>
      <td align="center">
        <span class="red">实验 3 提交</span>
      </td>
    </tr>
    <tr>
      <td align="center">3.22</td>
      <td align="center">
        <span class="red">实验 1 提交</span><br>
        <a href="arch-lab/lab2a.html">布置实验 2a</a>
      </td>
      <td align="center">5.17</td>
      <td align="center">
        <span class="red">实验 4 提交</span>
      </td>
    </tr>
    <tr>
      <td align="center">3.29</td>
      <td align="center">
        <a href="project/index.html">发布挑战课题</a><br>
        <a href="arch-lab/lab2b.html">布置实验 2b</a>
      </td>
      <td align="center">5.24</td>
      <td align="center">
      </td>
    </tr>
    <tr>
      <td align="center">4.5</td>
      <td align="center">
        <span class="green">清明节</span>
      </td>
      <td align="center">5.31</td>
      <td align="center">
      </td>
    </tr>
    <tr>
      <td align="center">4.12</td>
      <td align="center">
        <span class="red">实验 2 提交</span><br>
        <a href="arch-lab/lab3a.html">布置实验 3a</a>
      </td>
      <td align="center">6.7</td>
      <td align="center">
      </td>
    </tr>
    <tr>
      <td align="center">4.19</td>
      <td align="center">
        <a href="arch-lab/lab3b.html">布置实验 3b</a>
      </td>
      <td align="center">6.14</td>
      <td align="center">
        <span class="green">端午节</span><br>
        <span class="red">提交挑战项目</span>
      </td>
    </tr>
  </tbody>
</table>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="体系结构部分"><a class="header" href="#体系结构部分">体系结构部分</a></h1>
<p>本学期体系结构部分的实验将会实现一个 MIPS32 架构的基础 5 级流水线 CPU，并且将在 FPGA 开发板上进行测试。体系结构部分一共有 4 个需要提交的实验和一个挑战课题。</p>
<ul>
<li>实验 0：准备开发环境和测试环境。</li>
<li>实验 1：基础的五级流水线 MIPS CPU。</li>
<li>实验 2：访存仲裁和总线延时（2a）、多周期乘除法器（2b）。</li>
<li>实验 3：单周期缓存（cache）。</li>
<li>实验 4：MIPS 异常处理。</li>
<li>挑战课题：自由选择。</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-0开发环境"><a class="header" href="#实验-0开发环境">实验 0：开发环境</a></h1>
<p>这个实验将指导你们准备后续实验的开发环境，并且运行我们提供的标准 CPU 实现（RefCPU），以方便大家熟悉开发和测试的流程。<strong>本实验无需提交</strong>。</p>
<h2 id="安装-vivado"><a class="header" href="#安装-vivado">安装 Vivado</a></h2>
<p><strong>本学期的实验要求统一使用 Vivado 2019.2</strong>。</p>
<p>Vivado 可以在 Windows 环境和 Linux 环境<sup class="footnote-reference"><a href="#vivado-linux">1</a></sup>下安装。请参见<a href="arch-lab/../misc/external.html#2020-%E5%B9%B4%E9%BE%99%E8%8A%AF%E6%9D%AF%E6%96%87%E6%A1%A3">龙芯杯的资料</a>中的 “<i class="fa fa-file-pdf-o"></i> A6 - Vivado 安装说明” 来完成 Vivado 的安装。安装完成后，启动 Vivado 后应该能看到类似于下面的窗口：</p>
<p><img src="arch-lab/../asset/lab0/vivado.png" alt="Vivado 启动界面" /></p>
<h3 id="对于-linux-环境"><a class="header" href="#对于-linux-环境">对于 Linux 环境</a></h3>
<p>如果你不想折腾 Vivado 的安装，可以找助教索要打包好的 Vivado 文件 “<i class="fa fa-file-zip-o"></i> xilinx.tar” 来省去下载和安装的步骤。</p>
<p>Linux 下 Vivado 的安装器不会安装 cable driver。我们需要手动安装 cable driver 后才能将 FPGA 开发板连接到 Vivado 上。请在终端中执行下面的命令来安装 cable driver：</p>
<pre><code class="language-shell">export VIVADO_ROOT=/opt/xilinx/Vivado/2019.2
cd $VIVADO_ROOT/data/xicom/cable_drivers/lin64/install_script/install_drivers
sudo ./install_drivers
</code></pre>
<p><code>VIVADO_ROOT</code> 是 Vivado 的安装位置。如果在安装时没有改动安装位置，默认位置是 <code>/opt/xilinx/Vivado/2019.2</code>。</p>
<p>如果你安装完成后找不到 Vivado 的启动项，可以在终端中启动 Vivado：</p>
<pre><code class="language-shell">cd $VIVADO_ROOT
source ./settings64.sh
vivado
</code></pre>
<p>此外你可以考虑<a href="https://forums.xilinx.com/t5/Design-Entry/Can-t-launch-vivado-2018-3-in-ubuntu/m-p/935365/highlight/true#M23934">制作一个桌面启动项</a>。</p>
<h2 id="安装-verilator"><a class="header" href="#安装-verilator">安装 Verilator</a></h2>
<p>本学期的实验会引入 Verilator 作为 Vivado 外的另一个仿真器。除了 Verilator 本身外，我们还需要一些其它的软件包才能进行完整的仿真和调试的流程。请参考课程的 GitHub 仓库首页的 “<i class="fa fa-file"></i> README.md” 中的指示来安装这些软件包。</p>
<p>我们建议你在 Linux 环境下使用 Verilator。我们会保证 Verilator 的测试至少能够在 Ubuntu 20.04 上工作。其它版本的 Linux 的发行版（例如 Ubuntu 18.04、Manjaro、ArchLinux）理论上也是可以无障碍使用 Verilator 仿真的。如果你想在 Windows 上进行实验，我们建议你使用 WSL2 或者运行一个虚拟机。</p>
<h2 id="下载-git-仓库"><a class="header" href="#下载-git-仓库">下载 Git 仓库</a></h2>
<p>本学期的实验将会使用 Git 来做版本管理。你们的所有代码都将放在 Git 仓库中的指定位置，然后通过我们提供的脚本和 Vivado 工程文件（.xpr）来进行仿真和上板测试。因此，你需要在你的系统上安装 Git。想必很多同学都已经接触过 Git 了，因此这里就不再赘述 Git 的安装和配置流程了。</p>
<p>实验内容将在后续陆续放出。为了避免与你的工作 Git 分支有冲突，请避免直接在 master/main 分支以及 lab0、lab1、lab2、... 这些分支上做改动。我们建议你新建一个 dev 分支来编写你的代码：</p>
<pre><code class="language-shell">git checkout -b dev
</code></pre>
<p>当有新的实验内容放出时（例如布置了实验 2），将你的 dev 分支 rebase 到新的实验的分支上：</p>
<pre><code class="language-shell">git fetch origin
git checkout dev
git rebase origin/lab2
</code></pre>
<p>如果在 rebase 时发生冲突，请阅读 Git 输出的消息，并根据 Git 的指示解决冲突后，再使用 <code>git rebase --continue</code> 恢复 rebase 流程。直到没有冲突产生并且 rebase 完成为止。</p>
<h2 id="refcpu"><a class="header" href="#refcpu">RefCPU</a></h2>
<p>在 Git 仓库的 <code>source/refcpu</code> 目录下，有我们提供的标准 CPU（RefCPU）的源代码。RefCPU 是一个多周期 CPU，其可以通过龙芯杯的所有功能测试和性能测试。我们本学期的测试主要是龙芯杯的功能测试和性能测试，因此你可以用 RefCPU 来作为你的流水线 CPU 的对照。当然，我们不能保证 RefCPU 完全没有 BUG。如果 RefCPU 有不符合 <a href="arch-lab/../misc/external.html#mips-%E6%9E%B6%E6%9E%84">MIPS 标准</a>的行为，请以 MIPS 标准为准，并且可以向助教反馈。</p>
<p>接下来将使用 RefCPU 来运行一些测试，方便大家熟悉开发流程。</p>
<h3 id="运行测试-1"><a class="header" href="#运行测试-1">运行测试 1</a></h3>
<p>在仓库的 <code>vivado</code> 目录下有来自龙芯杯的测试。以测试 1 为例，在 Vivado 中打开文件 <code>vivado/test1/soc_axi_func/run_vivado/mycpu_prj1/mycpu.xpr</code>。然后点击顶部菜单栏的 “Tools” → “Run Tcl Script...”：</p>
<p><img src="arch-lab/../asset/lab0/vivado-refcpu-test1-2.png" alt="“Run Tcl Script...”" /></p>
<p>在弹出的对话框中选择 Git 仓库中的文件 <code>source/refcpu/add_sources.tcl</code>。这个 Tcl 脚本会将所有的 RefCPU 的源代码加入到 Vivado 的工程中。你可能注意到 <code>source/mycpu</code> 目录下也有个 <code>add_sources.tcl</code>，这个 Tcl 脚本就是以后加入你自己的 CPU 的源码时会用到的。源码加入后等待 Vivado 处理完成，就能在 “Sources” 窗口里看到新加入的源码/模块：</p>
<p><img src="arch-lab/../asset/lab0/vivado-refcpu-test1-4.png" alt="“Sources” 窗口" /></p>
<p>之后在左侧的 “Flow Navigator” 里面点击 “Run Simulation” → “Run Behavioral Simulation” 启动仿真。第一次仿真前因为需要综合 IP 核，所以可能比较慢，需要等待若干分钟才能启动<sup class="footnote-reference"><a href="#generate-ip">2</a></sup>。之后仿真的启动速度会快很多。</p>
<p><img src="arch-lab/../asset/lab0/vivado-refcpu-test1-simulation.gif" alt="启动仿真" /></p>
<p>点击界面下侧的 “Tcl Console” 可以看到仿真测试的输出。如果测试通过，最后应该能在这里看到类似于下面的输出：</p>
<pre><code class="language-plaintext">        [17532000 ns] Test is running, debug_wb_pc = 0xbfc100d8
        [17542000 ns] Test is running, debug_wb_pc = 0xbfc10178
        [17552000 ns] Test is running, debug_wb_pc = 0xbfc10218
        [17562000 ns] Test is running, debug_wb_pc = 0xbfc102bc
----[17563425 ns] Number 8'd29 Functional Test Point PASS!!!
        [17572000 ns] Test is running, debug_wb_pc = 0xbfc008f4
==============================================================
Test end!
----PASS!!!
$finish called at time : 17579574500 ps : File &quot;/home/riteme/Downloads/ICS-2021Spring-FDU/vivado/test1/soc_axi_func/testbench/mycpu_tb.v&quot; Line 269
run: Time (s): cpu = 00:00:17 ; elapsed = 00:03:32 . Memory (MB): peak = 7061.156 ; gain = 0.000 ; free physical = 3362 ; free virtual = 19061
</code></pre>
<h3 id="测试-1-上板"><a class="header" href="#测试-1-上板">测试 1 上板</a></h3>
<p>想必你们在上学期已经学习过如何生成比特流文件并且将其烧录到 FPGA 开发板上了。在测试 1 的工程中直接生成比特流，然后上板运行，最终应该能看到下面的效果：</p>
<p><img src="arch-lab/../asset/lab0/refcpu-test1-on-board.jpg" alt="上板效果" /></p>
<p>（NOTE：这是一张老图，最新的测试 1 的数码管两侧应该显示 “1c”）</p>
<h3 id="verilator-仿真"><a class="header" href="#verilator-仿真">Verilator 仿真</a></h3>
<p>本学期会使用 Verilator 做一些额外的测试。你可以阅读附加资料中的 <a href="arch-lab/../misc/verilate.html">Verilator 仿真</a>来了解一些基本的注意事项。</p>
<p>首先在 Git 仓库根目录打开一个终端，使用以下命令来用 RefCPU 跑龙芯杯的功能测试：</p>
<pre><code class="language-shell">make vsim -j
</code></pre>
<p>最后应该能看到类似于下面的输出：</p>
<pre><code class="language-plaintext">CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: load: ignored unknown destination 0x8ffc.
(info) #77 completed.
(info) #78 completed.
(info) #79 completed.
(info) #80 completed.
(info) #81 completed.
(info) #82 completed.
(info) #83 completed.
(info) #84 completed.
(info) #85 completed.
(info) #86 completed.
(info) #87 completed.
(info) #88 completed.
(info) #89 completed.
(info) testbench finished in 905987 cycles (599.199 KHz).
(warn) TextDiff: 7 error(s) suppressed.
</code></pre>
<p>然后用 RefCPU 运行龙芯杯性能测试中的 CoreMark：</p>
<pre><code>make vsim -j VSIM_ARGS='--force-diff -m &quot;./misc/nscscc/coremark.coe&quot; -r &quot;./misc/std/coremark.txt&quot;'
</code></pre>
<p>最后应该能看到如下的输出：</p>
<pre><code class="language-plaintext">./build/gcc/refcpu/VTop/vmain --force-diff -m &quot;./misc/nscscc/coremark.coe&quot; -r &quot;./misc/std/coremark.txt&quot;
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: load: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: store: ignored unknown destination 0x8ffc.
CONFREG: load: ignored unknown destination 0x8ffc.
coremark test begin.
arg : 0, 0, 102, 1, 7, 1, 2000
test start
computation done
2K performance run parameters for coremark.
CoreMark Size    : 666
Total ns : 24578460
Iterations/Sec : 40
COREMARK/MHZ = (1000000.0/CPU_COUNT_PER_US)*NSEC_PER_USEC*results[0].iterations/total_ns
It equals to 1000*1000*iteration/total_ns
In this run, iterate=1, total_ns=24578460

Total ticks      : 0
Total time (secs): 0
Iterations       : 1
Compiler version : GCC4.3.0
Compiler flags   :
Memory location  : Please put data memory location here
                        (e.g. code in flash, data on heap etc)
seedcrc          : 0xe9f5
[0]crclist       : 0xe714
[0]crcmatrix     : 0x1fd7
[0]crcstate      : 0x8e3a
[0]crcfinal      : 0xe714
Correct operation validated. See readme.txt for run and reporting rules.
coremark PASS!
coremark: Total Count(SoC count) = 0x2903e1
coremark: Total Count(CPU count) = 0x290399
(info) testbench finished in 2709066 cycles (612.085 KHz).
</code></pre>
<h3 id="使用-gtkwave"><a class="header" href="#使用-gtkwave">使用 GTKWave</a></h3>
<p>Verilator 仿真可以生成 FST 格式的波形图，需要使用一个上古开源软件 <a href="https://github.com/gtkwave/gtkwave"><i class="fa fa-github"></i> GTKWave</a> 来查看。我们提供了 <code>misc/demo.fst</code> 和 <code>misc/demo.gtkw</code> 作为样例波形图文件，供大家体验 GTKWave 的使用。GTKWave 的基本操作请参阅<a href="arch-lab/../misc/gtkwave.html"> “使用 GTKWave”</a>。</p>
<hr />
<div class="footnote-definition" id="vivado-linux"><sup class="footnote-definition-label">1</sup>
<p>虽然 Xilinx 官方声明中只支持 Ubuntu，但实际上其它大多数 Linux 发行版都能正常安装和使用 Vivado。</p>
</div>
<div class="footnote-definition" id="generate-ip"><sup class="footnote-definition-label">2</sup>
<p>你也可以在 “Sources” 的 “IP Sources” 一栏里面提前生成所有的 IP 核（选中所有 IP 核，右键并点击 “Generate Output Products”）。这样可以同时综合多个 IP 核，速度更快，并且不用综合完就可以仿真。</p>
</div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-1五级流水线-mips-cpu"><a class="header" href="#实验-1五级流水线-mips-cpu">实验 1：五级流水线 MIPS CPU</a></h1>
<blockquote>
<p>先修内容：《深入学习计算机系统》Chapter 4: Pipelined Y86 CPU</p>
</blockquote>
<h2 id="11-mips-微体系结构"><a class="header" href="#11-mips-微体系结构">1.1 MIPS 微体系结构</a></h2>
<p>五级流水线，属于体系结构的范畴。不同指令集的 CPU，都可以有五级流水线的实现。</p>
<p>指令集是微体系结构的一部分，规范了指令编码等信息。</p>
<p>MIPS 属于精简指令集（Reduced Instruction Set Computing，RISC）。我们需要实现的 MIPS，部分基本信息如下：</p>
<ul>
<li>每条指令长度为 4 字节（32 位）。</li>
<li>32 个通用寄存器，每个寄存器 32 位。0 号寄存器只读恒为 0。</li>
<li>内存读写的最小单位为 1 字节（8 位）。</li>
</ul>
<h3 id="111-mips-指令集"><a class="header" href="#111-mips-指令集">1.1.1 MIPS 指令集</a></h3>
<p>详见 <a href="arch-lab/../misc/external.html#mips-%E6%9E%B6%E6%9E%84">MIPS 手册 Ⅱ</a>：<i class="fa fa-file-pdf-o"></i> Volume II: MIPS32 Instruction Set。</p>
<p>这里介绍一下本实验中将要实现的部分指令：</p>
<hr />
<p><code>01ae5821		addu t3,t5,t6</code></p>
<table><thead><tr><th>[31:26]:000000</th><th>[25:21]:01101</th><th>[20:16]:01110</th><th>[15:11]:01011</th><th>[10:6]:00000</th><th>[5:0]:100001</th></tr></thead><tbody>
<tr><td>指令类型：寄存器类型</td><td>rs: t5</td><td>rt: t6</td><td>rd: t3</td><td>全 0</td><td>ADDU</td></tr>
</tbody></table>
<p>操作：<code>Reg[rd] ← Reg[rs] + Reg[rt]</code></p>
<hr />
<p><code>25290001		addiu t1,t1,1</code></p>
<table><thead><tr><th>[31:26]:001001</th><th>[25:21]:01001</th><th>[21:16]:01001</th><th>[15:0]:0000_0000_0000_0001</th></tr></thead><tbody>
<tr><td>指令类型：ADDIU</td><td>rs: t1</td><td>rt: t1</td><td>立即数 immediate</td></tr>
</tbody></table>
<p>操作：<code>Reg[rt] = Reg[rs] + Sign_Extend(immediate)</code></p>
<p>注意：该指令中的 u 表示寄存器为无符号的，是为了忽略溢出（和 C 语言的 <code>int</code>、<code>unsigned</code> 加法语义一致），立即数仍需符号位扩展。有一部分指令的立即数是 0 扩展。</p>
<hr />
<p><code>8d0c0000 lw t4,0(t0)</code></p>
<table><thead><tr><th>[31:26]:100011</th><th>[25:21]:01000</th><th>[20:16]:01100</th><th>[15:0]:0000_0000_0000_0000</th></tr></thead><tbody>
<tr><td>指令类型：LW</td><td>base: t0</td><td>rt: t4</td><td>offset</td></tr>
</tbody></table>
<p>操作：</p>
<ul>
<li><code>vaddr ← Reg[base] + Sign_Extend(offset)</code></li>
<li><code>if (vaddr[1:0] != 2'b0) Exception(Address Exception)</code>（本实验中，可以保证 <code>vaddr</code> 是 4 字节对齐）</li>
<li><code>Reg[rt] ← LoadMemory(AddressTranslation(vaddr), size = WORD)</code></li>
</ul>
<hr />
<p><code>pc = bfc00704:  	0ff00f00		jal	bfc03c00 &lt;n1_lui_test&gt;</code></p>
<table><thead><tr><th>[31:26]:000011</th><th>[25:0]:11_1111_0000_0000_1111_0000_0000</th></tr></thead><tbody>
<tr><td>指令类型：JAL（jump and link）</td><td>instr_index</td></tr>
</tbody></table>
<p>操作：</p>
<ul>
<li><code>Reg[31] ← pc + 8</code></li>
<li>执行下一条指令时：<code>pc ← {pc[31:28], instr_index, 2'b00}</code></li>
</ul>
<p>JAL 指令常用于函数调用。</p>
<pre><code class="language-mips"># note: in MIPS, branch-type instructions (including j, beq) have a delay slot.

sample1:
beq zero, zero, here # branch if equal
instruction1
instruction2

here:
instruction3

# sequence is: beq -&gt; instruction1 -&gt; instruction3


sample2:
bne zero, zero, there # branch if not equal
instruction 4
instruction 5
instruction 6

there:
instruction 7

# sequence is: bne -&gt; instruction 4 -&gt; instruction 5
</code></pre>
<p>本实验需要实现的指令：<code>lui</code>、<code>addu</code>、<code>addiu</code>、<code>beq</code>、<code>bne</code>、<code>lw</code>、<code>or</code>、<code>slt</code>、<code>slti</code>、<code>sltiu</code>、<code>sll</code>、<code>sw</code>、<code>j</code>、<code>jal</code>、<code>jr</code>、<del><code>addi</code></del>、<code>subu</code>、<code>sltu</code>、<code>and</code>、<code>andi</code>、<code>nor</code>、<code>ori</code>、<code>xor</code>、<code>xori</code>、<code>sra</code>、<code>srl</code>、<del><code>jalr</code></del>。</p>
<h3 id="112-虚实地址转换"><a class="header" href="#112-虚实地址转换">1.1.2 虚实地址转换</a></h3>
<p>指令代码、寄存器中的地址都是虚拟地址。CPU 向内存请求时，需要提供物理地址。</p>
<p>本实验中，只要求实现简单的虚实地址转换。</p>
<pre><code class="language-verilog">typedef logic [31:0] paddr_t;
typedef logic [31:0] vaddr_t;

paddr_t paddr; // physical address
vaddr_t vaddr; // virtual address

assign paddr[27:0] = vaddr[27:0];
always_comb begin
    unique case (vaddr[31:28])
        4'h8: paddr[31:28] = 4'b0; // kseg0
        4'h9: paddr[31:28] = 4'b1; // kseg0
        4'ha: paddr[31:28] = 4'b0; // kseg1
        4'hb: paddr[31:28] = 4'b1; // kseg1
        default: paddr[31:28] = vaddr[31:28]; // useg, ksseg, kseg3
    endcase
end
</code></pre>
<p>亦可以参考 RefCPU 中模块 <code>AddressTranslator</code> 的实现。</p>
<p>例如，当指令访问地址 <code>0xbfc00380</code> 时，实际访问的物理地址应该是 <code>0x1fc00380</code>。详见 <a href="arch-lab/../misc/external.html#mips-%E6%9E%B6%E6%9E%84">MIPS 手册 Ⅲ</a>：<i class="fa fa-file-pdf-o"></i> Volume III: MIPS32 Privileged Resource Architecture，第 29 页。</p>
<h2 id="12-五级流水线"><a class="header" href="#12-五级流水线">1.2 五级流水线</a></h2>
<p>五级流水线的简单示意图如下：</p>
<p><img src="arch-lab/../asset/lab1/5-stage.png" alt="5-stage" /></p>
<p>虚线上方为内存部分的硬件，由测试文件提供。</p>
<p>写 CPU，就是实现 CPU 的内部，并用事先定好的接口进行封装。</p>
<h3 id="121-select-pc"><a class="header" href="#121-select-pc">1.2.1 Select PC</a></h3>
<p>这一阶段在 Fetch Pipeline Register 前，选择流水线所执行的下一条指令的 PC。</p>
<p>可能的来源：</p>
<ul>
<li>顺序的下一条指令（PC + 4）</li>
<li>jump 类指令（<code>{pc[31:28], instr_index, 2'b00}</code>）</li>
</ul>
<p>等等。</p>
<h3 id="122-fetch"><a class="header" href="#122-fetch">1.2.2 Fetch</a></h3>
<p>向 Instruction Memory 提供指令地址，并接收指令。</p>
<p>注意：本实验中，内存有 1 周期的固定延迟。</p>
<p>其行为类似于：</p>
<pre><code class="language-verilog">logic [127:0][31:0] memory;
logic [6:0] addr;
logic [31:0] data;
always_ff @(posedge clk) begin
    data &lt;= memory[addr];
end
</code></pre>
<p>可考虑把接受的数据直接接到下一流水段。</p>
<h3 id="123-decode"><a class="header" href="#123-decode">1.2.3 Decode</a></h3>
<p>D 阶段完成：</p>
<ul>
<li>指令解码，生成控制信号</li>
<li>从 Regfile（寄存器文件堆）中读取数据</li>
<li>判断是否跳转</li>
</ul>
<h3 id="124-execute"><a class="header" href="#124-execute">1.2.4 Execute</a></h3>
<p>E 阶段主要为 ALU。</p>
<h3 id="125-memory"><a class="header" href="#125-memory">1.2.5 Memory</a></h3>
<p>M 阶段向 Data Memory 提供数据地址，并接收数据。</p>
<p>注意：本实验中，内存有 1 周期固定延迟。</p>
<h3 id="126-writeback"><a class="header" href="#126-writeback">1.2.6 Writeback</a></h3>
<p>W 阶段向 Regfile 写数据。</p>
<h3 id="127-regfile"><a class="header" href="#127-regfile">1.2.7 Regfile</a></h3>
<p>根据 MIPS 指令集架构，每条指令最多写 1 个通用寄存器，最多读 2 个通用寄存器。所以 Regfile 应设计为 1 个写端口，2 个读端口。</p>
<p>参考代码：</p>
<pre><code class="language-verilog">typedef logic[31:0] word_t;
typedef logic[4:0] creg_addr_t;

module regfile(
	input logic clk,
    input creg_addr_t ra1, ra2, wa3,
    input logic write_enable,
    input word_t wd3
    output word_t rd1, rd2
);
    word_t [31:1] regs, regs_nxt;

    // write: sequential logic
    always_ff @(posedge clk) begin
        regs[31:1] &lt;= regs_nxt[31:1];
    end
    for (genvar i = 1; i &lt;= 31; i ++) begin
        always_comb begin
            regs_nxt[i[4:0]] = regs[i[4:0]];
            if (wa3 == i[4:0] &amp;&amp; write_enable) begin
                regs_nxt[i[4:0]] = wd3;
            end
        end
    end


    // read: combinational logic
    assign rd1 = (ra1 == 5'b0) ? '0 : regs[ra1]; // or regs_nxt[ra1] ?
    assign rd2 = (ra2 == 5'b0) ? '0 : regs[ra2];

endmodule
</code></pre>
<h3 id="128-pipeline-register"><a class="header" href="#128-pipeline-register">1.2.8 Pipeline register</a></h3>
<p>五级流水线中，会有阻塞与气泡，所以流水线寄存器需要提供这些机制。</p>
<p>参考代码：</p>
<pre><code class="language-verilog">typedef struct packed {
    logic a;
} fetch_data_t;

module dreg (
	input logic clk, resetn,
    input fetch_data_t dataF_new,
    input logic enable, flush,
    output fetch_data_t dataF
);
    always_ff @(posedge clk) begin
        if (~resetn | flush) begin // flush overrides enable
            dataF &lt;= '0;
        end else if (enable) begin
            dataF &lt;= dataF_new;
        end
    end
endmodule
</code></pre>
<p>Tips：</p>
<ul>
<li>W 阶段流水线寄存器不允许被阻塞。</li>
<li>F 阶段流水线寄存器一般不清零；<strong>PC的复位值为 <code>32'hbfc0_0000</code></strong>。</li>
<li>M 阶段流水线寄存器阻塞时（因），E 阶段流水线寄存器通常也阻塞（果），防止丢失指令。</li>
<li>E 阶段流水线寄存器阻塞时（因），M 阶段流水线寄存器通常清零（果），防止指令被执行多次。</li>
</ul>
<h3 id="129-hazard-and-forward"><a class="header" href="#129-hazard-and-forward">1.2.9 Hazard and Forward</a></h3>
<p>这个部分代码量可能不大，但应该是本实验中最复杂的部分。</p>
<p>主要难点是数据冲突。本实验中，仅需考虑写后读（RAW）冲突。请思考：</p>
<ul>
<li>冲突阻塞部分：D 阶段取数据，E、M、W 阶段的写数据会造成冲突。哪些情况应当阻塞流水线？</li>
<li>转发部分：哪些指令写通用寄存器？电路图中的哪些数据线可作为转发来源？转发条件是什么？优先级是什么？</li>
</ul>
<p>分支预测失败的情况比较简单。D 阶段判断分支是否跳转；由于 delay slot 的设计，F 阶段的指令一定执行。所以，分支跳转不会有额外的惩罚（数据冲突可能存在）。</p>
<h3 id="1210-封装-cpu"><a class="header" href="#1210-封装-cpu">1.2.10 封装 CPU</a></h3>
<p>本实验的 CPU 的最顶层封装为 SRAM 接口。见 <code>source/mycpu/mycpu_top.sv</code>。</p>
<pre><code class="language-verilog">module mycpu_top (
    input logic clk,
    input logic resetn,  // low active
    input logic[5:0] ext_int,  // interrupt, high active

    output logic inst_sram_en,              // 指令内存总使能
    output logic[3:0] inst_sram_wen,        // 字节写使能，本实验中为全 0
    output logic[31:0] inst_sram_addr,      // 地址
    output logic[31:0] inst_sram_wdata,     // 写数据
    input logic[31:0] inst_sram_rdata,      // 读数据

    output logic data_sram_en,              // 数据内存总使能
    output logic[3:0] data_sram_wen,        // 字节写使能，本实验中为全 0 或全 1
    output logic[31:0] data_sram_addr,      // 地址
    output logic[31:0] data_sram_wdata,     // 写数据
    input logic[31:0] data_sram_rdata,      // 读数据

    //debug
    output logic[31:0] debug_wb_pc,         // W 阶段 PC
    output logic[3:0] debug_wb_rf_wen,      // 写使能，一般为全 0 或全 1
    output logic[4:0] debug_wb_rf_wnum,     // 写入的寄存器
    output logic[31:0] debug_wb_rf_wdata    // 写回的数据
);
    // TODO: other circuit

endmodule
</code></pre>
<p>为了保证和后续实验在接口上的统一，我们在 CPU 内部统一使用 DBus 接口。在 <code>source/mycpu/SRAMTop.sv</code> 做了从 DBus 接口到类 SRAM 接口的转换。DBus 接口定义在 <code>source/include/common.svh</code> 中：</p>
<pre><code class="language-verilog">typedef struct packed {
    logic    valid;   // 是否有请求？
    addr_t   addr;    // 请求读写的地址
    msize_t  size;    // 读写数据的大小：1、2 或者 4 字节，分别对应 MSIZE1、MSIZE2 和 MSIZE4
    strobe_t strobe;  // 4 位的字节写使能信号
    word_t   data;    // 如果写使能不为全 0，这里放写入的数据
} dbus_req_t;

typedef struct packed {
    logic  addr_ok;  // 内存是否已经接收了地址？
    logic  data_ok;  // 内存是否完成了访存？
    word_t data;     // 请求地址处读出的数据
} dbus_resp_t;
</code></pre>
<p>对于本次实验，因为访存是固定延时，并且所有读写的数据以及指令访存都是 4 字节的，所以</p>
<ul>
<li><code>dbus_resp_t</code> 中的 <code>addr_ok</code> 和 <code>data_ok</code> 信号实际上可以忽略。</li>
<li><code>addr</code> 最低两位应该始终为 0，即地址与 4 字节对齐。</li>
<li><code>size</code> 始终为 <code>MSIZE4</code>。</li>
<li>写操作时 <code>strobe</code> 为 <code>4'b1111</code> 或 <code>4'hf</code>。</li>
</ul>
<p>你可能会注意到还有一个 IBus 接口。IBus 接口是 DBus 接口的子集，只保留了读取数据所需要的信号。此外，你的流水线部分的顶层模块文件应该是 <code>source/mycpu/MyCore.sv</code>。我们建议你将你的流水线分为多个模块来实现。你可以在 <code>source/mycpu</code> 这个目录下新建文件或者子目录。</p>
<p>你可以选择在模块 <code>SRAMTop</code> 中做地址翻译，或是在模块 <code>MyCore</code> 中做地址翻译。</p>
<h3 id="1211-连接-debug_-信号"><a class="header" href="#1211-连接-debug_-信号">1.2.11 连接 <code>debug_*</code> 信号</a></h3>
<p>龙芯杯的测试会进行 trace 的比对。这需要从你的流水线中读取一些数据。我们在 1.2.10 一节中已经看到 <code>mycpu_top</code> 最后有四个 <code>debug_*</code> 信号了。为了避免增加下层模块的接口，我们建议你使用跨模块引用来连接这些 <code>debug_*</code> 信号。例如：</p>
<pre><code class="language-verilog">// in mycpu_top.sv
assign debug_wb_pc     = top.core.writeback.pc;
assign debug_wb_rf_wen = top.core.writeback.aha ? 4'b1111 : 4'b0;
</code></pre>
<h2 id="13-数据通路与译码控制信号"><a class="header" href="#13-数据通路与译码控制信号">1.3 数据通路与译码控制信号</a></h2>
<p>CPU 需要一系列硬件来执行指令所要求的功能。如果 CPU 只支持一条指令，那么 CPU 内所有的硬件都只为这一个功能所服务。随着指令条数的增加， CPU 设计者会添加一些硬件，同时也会复用一些原有的硬件。随着这些硬件复用性的提升， CPU 的数据通路会变得更复杂。Decode 阶段的译码器为这些硬件提供控制信号，这些控制信号也是高度复用的。</p>
<p>我们设计的第一条指令是 <code>addu</code>。只支持这一条指令的流水线，是比较简单的：</p>
<p><img src="arch-lab/../asset/lab1/datapath/addu.svg" alt="addu" /></p>
<p>随后，我们加入了 <code>addiu</code>。Execute 阶段的加法器可以被复用，但源操作数不再是两个寄存器的值，而是一个寄存器和一个立即数；目的寄存器也不再是 <code>rd</code>， 而是 <code>rt</code>：</p>
<p><img src="arch-lab/../asset/lab1/datapath/addiu.svg" alt="addiu" /></p>
<p><code>lw</code> 指令通过一个加法器算出数据的虚拟地址，这个加法器可以使用已有的加法器。然而，写入寄存器的数据不再是加法器，而是数据内存：</p>
<p><img src="arch-lab/../asset/lab1/datapath/sw.svg" alt="sw" /></p>
<p>添加了 <code>jal</code> 指令后，下一条指令的 PC 不再只可能是 (PC + 4)；写入的寄存器被指定为 31 号寄存器，数据则是指定为 (PC + 8)：</p>
<p><img src="arch-lab/../asset/lab1/datapath/jal.svg" alt="jal" /></p>
<p>当 CPU 需要支持新的指令时，根据该指令的功能，设计数据通路，并视具体情形添加或复用硬件与控制信号。添加硬件，会增加 CPU 的电路面积；复用原有硬件，会增加复用器的电路复杂性，增加电路延迟。</p>
<p>添加新硬件时，需考虑将该硬件放在流水线的哪一阶段，避免影响该流水段的逻辑延迟。</p>
<h2 id="14-流水线性能评估"><a class="header" href="#14-流水线性能评估">1.4 *流水线性能评估</a></h2>
<p>在本次实验中，我们实现了五级流水线 CPU。相对于单周期 CPU，流水线 CPU 牺牲了一些 IPC（流水线的数据冲突会阻塞流水线），换取频率的大幅提升。这一节主要分析流水线的性能。</p>
<h3 id="141-高延迟的逻辑部件"><a class="header" href="#141-高延迟的逻辑部件">1.4.1 高延迟的逻辑部件</a></h3>
<p>在本实验设计的 CPU 中，有以下几个高延迟的逻辑部件：</p>
<p><strong>寄存器文件</strong>：它的读逻辑和写逻辑都十分复杂。读过程的每一位是一个 32 选 1 的复用器，也就是 37 个变量的组合逻辑方程；读数据为 32 位，相当于上述逻辑复制 32 份。1 位寄存器的写逻辑比较简单，但 32 位的写入需要将该逻辑复制 32 次，电路就变得复杂了。</p>
<p><strong>算术逻辑单元 ALU</strong>：本实验需要实现的算数操作中，加法、比较运算的电路是级联，移位运算的电路是复用器；整个 ALU 的输出还需要一次复用。</p>
<p><strong>内存</strong>：本实验中不需要实现内存，但它在 CPU 的外部，数据传进来有很高的接线延迟。</p>
<h3 id="142-用转发来减少阻塞"><a class="header" href="#142-用转发来减少阻塞">1.4.2 用转发来减少阻塞</a></h3>
<p>在流水线中，写后读冲突会导致流水线阻塞。</p>
<p>如果需要的寄存器数据，在流水线的其他阶段已经计算好了，可以进行转发。</p>
<p>然而，转发会导致该阶段延迟的增加。下图的转发会大幅度增加 E 阶段的延迟：</p>
<p><img src="arch-lab/../asset/lab1/forward.svg" alt="forward" /></p>
<h3 id="143-pipeline-as-mechanism"><a class="header" href="#143-pipeline-as-mechanism">1.4.3 Pipeline as Mechanism</a></h3>
<p>单周期 CPU 中，时钟频率是不可控的：为了支持新的指令，需要向数据通路中添加新的逻辑部件，导致延迟将越来越高。</p>
<p>流水线是拆分数据通路的一种<strong>机制</strong>，它将各个高延迟的逻辑部件划分在不同的流水段，使得电路延迟变得<strong>可控</strong>。五级流水线是一种<strong>策略</strong>。根据现有的数据通路和频率要求，设计更深或更浅的流水线。</p>
<h2 id="15-发布包"><a class="header" href="#15-发布包">1.5 发布包</a></h2>
<p>用 Vivado 2019.2 打开 <code>vivado/test1_naive/soc_sram_func/run_vivado/mycpu_prj1/mycpu.xpr</code>，添加源文件后，即可开始仿真。</p>
<p>Tips：第一次仿真前，先点击 “IP Sources”，选中所有 IP 核源文件，右键，点击 “Generate Output Products”。几秒钟后，跳出 “OK”，然后再点仿真。</p>
<p><code>vivado/test1_naive/soft/obj/test.s</code> 是测试的反汇编文件，有 PC、机器码、汇编码的对应。<code>soft</code> 目录下的其他文件里，可以找到测试的 C 代码。</p>
<p><code>source/mycpu/</code> 里已经有一些代码，其中：</p>
<ul>
<li><code>mycpu_top.sv</code> 是顶层封装文件，仅需把 debug 信号连接上。</li>
<li><code>SRAMTop.sv</code> 是 SRAM 接口封装文件，需要添加虚实地址翻译。</li>
<li><code>MyCore.sv</code> 是 CPU 主体流水线文件。</li>
</ul>
<p>你可以在该目录下随意添加源文件。在 Vivado 中执行 <code>add_sources.tcl</code> 后，它们都会添加到项目里。</p>
<p><code>source/include/</code> 里有一些头文件。</p>
<p><strong>本次实验没有暂时没有使用 Verilator 进行仿真</strong>。我们会从实验 2 开始引入 Verilator，所以你需要确保你的在这次实验中编写的代码能够通过 Verilator 的编译。如果在使用 Verilator 中遇到了问题，请先阅读 <a href="arch-lab/../misc/verilate.html">Verilator 仿真</a>寻找解决方案。</p>
<h2 id="16-作业与提交"><a class="header" href="#16-作业与提交">1.6 作业与提交</a></h2>
<p>在 <code>source/mycpu/</code> 里添加你的代码，实现五级流水线 MIPS CPU。</p>
<p>本实验需要实现的指令：<code>lui</code>、<code>addu</code>、<code>addiu</code>、<code>beq</code>、<code>bne</code>、<code>lw</code>、<code>or</code>、<code>slt</code>、<code>slti</code>、<code>sltiu</code>、<code>sll</code>、<code>sw</code>、<code>j</code>、<code>jal</code>、<code>jr</code>、<del><code>addi</code></del>、<code>subu</code>、<code>sltu</code>、<code>and</code>、<code>andi</code>、<code>nor</code>、<code>ori</code>、<code>xor</code>、<code>xori</code>、<code>sra</code>、<code>srl</code>、<del><code>jalr</code></del>。</p>
<p><strong>PC的复位值为 <code>32'hbfc0_0000</code></strong>。</p>
<h3 id="161-通过标准"><a class="header" href="#161-通过标准">1.6.1 通过标准</a></h3>
<ol>
<li>打开原有 <code>mycpu.xpr</code>，用 <code>source/mycpu/add_sources.tcl</code> 添加源文件，上板显示两个绿灯。</li>
<li>在仓库根目录打开终端，运行 <code>make verilate TARGET=mycpu/VTop</code>，确认 Verilator 能够编译你的 CPU 代码，并且没有报告任何错误和警告。</li>
</ol>
<h3 id="162-实验报告要求"><a class="header" href="#162-实验报告要求">1.6.2 实验报告要求</a></h3>
<ul>
<li>格式：PDF</li>
<li>内容：按本文档 1.2 节的思路写即可。写好姓名学号。</li>
</ul>
<h3 id="163-提交文件格式"><a class="header" href="#163-提交文件格式">1.6.3 提交文件格式</a></h3>
<pre><code class="language-plaintext">18307130024/
├── report/（报告所在目录）
└── source/（源文件所在目录）
</code></pre>
<p>用 <code>zip -r 18307130024.zip 18307130024/</code> 打包。用 <code>unzip 18307130024.zip</code> 检查，应在当前目录下有学号目录。</p>
<h3 id="164-评分"><a class="header" href="#164-评分">1.6.4 评分</a></h3>
<p>代码 80%，报告 20%。</p>
<p><strong>Deadline：2021 年 3 月 21 日 23:59:59</strong></p>
<h2 id="17-思考"><a class="header" href="#17-思考">1.7 *思考</a></h2>
<ol>
<li>流水线寄存器的 flush 信号，需要让所有信号都清零吗？</li>
<li>转发的成本是什么？有哪些限制？（板子上的组合逻辑基本部件为 LUT6 ，6 输入 1 输出，可实现 6 输入的任何给定逻辑式）</li>
<li>不同指令需要用到的流水线阶段可能不同：加法指令似乎不需要经过 Memory 阶段。能让它跳过 M 阶段吗？</li>
</ol>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-2a总线仲裁与延时"><a class="header" href="#实验-2a总线仲裁与延时">实验 2a：总线仲裁与延时</a></h1>
<h2 id="仲裁"><a class="header" href="#仲裁">仲裁</a></h2>
<p>多个独立运行的实体同时访问共享资源时，往往需要通过仲裁决定访问的先后顺序。</p>
<p>在实验 1 中，CPU 有两套访存接口：一个用于取指，另一个用于读写数据。<code>test1_naive</code> 将指令内存和数据内存分开了，从而能够同时支持两边的访问。现实生活中的计算机架构一般遵循 von Neumann 架构，即指令和数据放在同一个内存中。此时需要内存有两个读写端口。</p>
<p>但是多端口的存储单元往往非常消耗资源（例如，6 端口寄存器文件）。现代的 CPU 的核心数量越来越多，提供多端口的存储单元非常不现实。此外，如果有两个或者更多的端口同时写入同一个位置时，我们需要规定谁的写入是有效的，此时发生了写入冲突。</p>
<p>解决这一问题的一种方法是仲裁，即当有多个实体同时访问同一个对象时，允许其中一个进行访问，要求其它的实体等待。这个过程类似于加锁互斥。</p>
<p><code>test1</code>~<code>test4</code> 的内存都只有一个端口，因此需要进行仲裁。</p>
<h2 id="延时"><a class="header" href="#延时">延时</a></h2>
<p>仲裁会导致等待，因此我们不能再期望数据会在固定的时间内返回。此外，现代 CPU 的主频和内存频率往往不同，并且 CPU 为了降低功耗通常会动态调频，因此增加了访存需要的周期数的不确定性。下表是 Intel 的 Skylake 架构中 cache 的各项参数，来自 “Intel 64 and IA-32 Architectures Optimization Reference Manual”：</p>
<p><img src="arch-lab/../asset/lab2/skylake-cache.png" alt="Skylake 的 cache 参数" /></p>
<p>可以看到各级缓存的访问所需要的周期数都是不一样的，并且都不是固定的。</p>
<h2 id="dbus"><a class="header" href="#dbus">DBus</a></h2>
<p>DBus 是一个单向握手协议，其定义在 <code>common.svh</code> 中：</p>
<pre><code class="language-verilog">typedef struct packed {
    logic    valid;   // in request?
    addr_t   addr;    // target address
    msize_t  size;    // number of bytes
    strobe_t strobe;  // which bytes are enabled? set to zeros for read request
    word_t   data;    // the data to write
} dbus_req_t;

typedef struct packed {
    logic  addr_ok;  // is the address accepted by cache?
    logic  data_ok;  // is the field &quot;data&quot; valid?
    word_t data;     // the data read from cache
} dbus_resp_t;
</code></pre>
<h3 id="总线握手"><a class="header" href="#总线握手">总线握手</a></h3>
<p>DBus 的逻辑是：由 CPU 主动发出请求（拉起 <code>valid</code> 信号），等待内存给出反馈（<code>addr_ok</code> 和 <code>data_ok</code>）。DBus 的反馈分为两个阶段，一是内存已经得知并且缓存了 CPU 的请求，此时内存会将 <code>addr_ok</code> 拉起；二是内存已经完成了 CPU 的请求，此时将 <code>data_ok</code> 拉起。这两个过程就是所谓的 “握手”。握手是一个时序逻辑。每当时钟周期上升沿触发时，如果 <code>addr_ok</code> 为 <code>1</code>，表明握手成功。<code>data_ok</code> 同理。例如，CPU 想写入内存，内存也支持单周期写入，此时内存会把 <code>addr_ok</code> 和 <code>data_ok</code> 同时设为 <code>1</code>。等到时钟上升沿到达时，内存就会触发写入，同时 CPU 也知道内存已经完成这个写入了。</p>
<p><img src="arch-lab/../asset/lab2/single-cycle.svg" alt="单周期访存" /></p>
<p>如果内存需要多个周期才能完成一次访存，CPU 需要一直拉起 <code>valid</code> 信号，直到内存的 <code>addr_ok</code> 响应。</p>
<p><img src="arch-lab/../asset/lab2/multi-cycle.svg" alt="多周期访存" /></p>
<p>访存有一个常见的优化是写缓冲区（store buffer）。写缓冲会保存收到的请求，发出 <code>addr_ok</code>，然后再进行真正的写内存操作。CPU 一般不用关心写操作是否真的完成了，因此流水线在收到 <code>addr_ok</code> 的时候就可以继续推进。这样可以明显减少写内存带来的流水线阻塞。</p>
<p><img src="arch-lab/../asset/lab2/store-buffer.svg" alt="写缓冲区优化" /></p>
<p>访存也可以切分流水线。CPU 的 fetch 阶段和 memory 阶段可以分为多个周期完成，此时需要 cache 也按照流水线的方式工作。这样即便单次访存的延时很高，cache 提供的吞吐率却不低。</p>
<p><img src="arch-lab/../asset/lab2/pipelined.svg" alt="流水线化访存" /></p>
<p>注意：CPU 收到 <code>addr_ok</code> 后，如果没有其它请求，必须把 <code>valid</code> 撤下。</p>
<h3 id="size-信号"><a class="header" href="#size-信号"><code>size</code> 信号</a></h3>
<p><code>size</code> 是一个枚举。DBus 支持 <code>MSIZE1</code>（单字节）、<code>MSIZE2</code>（双字节）和 <code>MSIZE4</code>（四字节）三种模式。</p>
<h3 id="byte-lanes"><a class="header" href="#byte-lanes">Byte Lanes</a></h3>
<p>DBus 是 32 位的总线，每周期至多传输 4 个字节。<code>data</code> 的四个字节可以视作四个独立的通道 <code>lane[3:0]</code>，<code>lane[0]</code> 对应地址最后两位为 <code>2'b00</code> 的那个字节，<code>lane[1]</code> 对应最后两位为 <code>2'b01</code> 的字节，依次类推。因此，无论我们给出的地址是否与 4 字节对齐，<code>data</code> 中的数据依然会按照 4 字节对齐的方式摆放。DBus 提供一个 4 位的写使能 <code>strobe[3:0]</code>，<code>strobe[0]</code> 表示 <code>lane[0]</code> 是否启用，<code>strobe[3..1]</code> 类似。通过这种方式，DBus 允许写入比 4 字节窄的数据。</p>
<p>例如，我们向地址 <code>0xbfc001f2</code> 写入单个字节的数据 <code>0xcd</code> 时，由于地址的最低两位为 <code>0x2</code>（<code>2'b10</code>），所以我们应该：</p>
<ul>
<li>地址 <code>addr</code> 依然是 <code>32'hbfc001f2</code>。</li>
<li>将 <code>data</code> 设置为 <code>32'h00cd0000</code>。</li>
<li>将 <code>strobe</code> 设置为 <code>4'b0100</code>。</li>
</ul>
<p>这么做可能比较反直觉。DBus 的 byte lanes 来源于 AXI 总线协议，其意图在于兼容只能 4 字节对齐寻址的设备（一般的内存都是这么做的），同时不要求 <code>addr</code> 必须与 4 字节对齐是因为可能会和只能字节寻址的设备交互（例如字符打印）。</p>
<p>换句话说，当你向 <code>0x1f2</code> 发送读取请求时，DBus 会把 <code>0x1f0</code>、<code>0x1f1</code>、<code>0x1f2</code> 和 <code>0x1f3</code> 这四个地址对应的字节全部返回给你，分别放在 <code>data[7:0]</code>、<code>data[15:8]</code>、<code>data[23:16]</code> 和 <code>data[31:24]</code> 中。同样的，当你向 <code>0x1f2</code> 这个地址写入时，实际上是同时向 <code>0x1f0</code>、<code>0x1f1</code>、<code>0x1f2</code> 和 <code>0x1f3</code> 这四个地址对应的字节写入，不过此时我们可以使用 <code>strobe</code> 信号单独决定每个字节是否真的需要写入。</p>
<p>下面展示了从地址 <code>0xbfc01fc2</code> 开始连续写入 15 个字节 <code>0x11</code>~<code>0xff</code> 的过程：</p>
<p><img src="arch-lab/../asset/lab2/byte-lanes.svg" alt="DBus 连续写入示例" /></p>
<h3 id="ibus"><a class="header" href="#ibus">IBus</a></h3>
<p>IBus 是 DBus 的子集，仅保留了读取 4 字节（<code>word_t</code>）的接口。</p>
<h2 id="实验内容"><a class="header" href="#实验内容">实验内容</a></h2>
<p>下面将分步骤介绍本实验要完成的内容。</p>
<h3 id="支持总线延时"><a class="header" href="#支持总线延时">支持总线延时</a></h3>
<p>在 <code>mycpu_top.sv</code> 的开头，有一个宏 <code>FIXED_LATENCY</code> 确定该模块使用类 SRAM 接口还是 AXI 接口：</p>
<pre><code class="language-verilog">/**
 * TODO (Lab2) comment out the following line :)
 */
`define FIXED_LATENCY

module mycpu_top (
`ifdef FIXED_LATENCY
    // ...
</code></pre>
<p>本次实验你需要将这一行 <code>define</code> 注释掉。之后</p>
<ul>
<li><code>mycpu_top</code> 会使用 AXI 接口。</li>
<li>仿真的顶层模块从 <code>SRAMTop</code> 变成 <code>VTop</code>。
<ul>
<li>如果你上一次实验的地址翻译放在 <code>SRAMTop</code>，你可能需要将它们迁移到 <code>VTop</code>。</li>
</ul>
</li>
</ul>
<p>这里只修改了 <code>mycpu_top</code> 的接口，<code>MyCore</code> 依然使用 DBus/IBus。你不需要关心 AXI 接口是如何操作的。如果你感兴趣，可以自行阅读 <code>util</code> 文件夹下的 <code>CBusToAXI.sv</code>。</p>
<p>你需要修改流水线寄存器的阻塞逻辑。一条 <code>lw</code> 指令在 memory 阶段发出访存请求，在数据返回前，显然需要阻塞流水线。</p>
<p>一个简单的改动如下：</p>
<pre><code class="language-verilog">assign stallF = ~i_data_ok | ~d_data_ok;
assign stallD = ~i_data_ok | ~d_data_ok;
assign stallE = ~d_data_ok;
assign stallM = ~d_data_ok;
assign flushE = ~i_data_ok;
assign flushW = ~d_data_ok;
</code></pre>
<p>注意：这个处理的性能未必好，内存的写请求不一定需要进行 <code>data_ok</code> 的握手。</p>
<p>完成后，你应该能够通过 <code>vivado/test1</code> 的测试。</p>
<h3 id="实现仲裁器"><a class="header" href="#实现仲裁器">*实现仲裁器</a></h3>
<p>我们已经提供了一个简单的仲裁器实现，在 <code>source/util/CBusArbiter.sv</code> 中。<code>VTop</code> 默认使用 <code>CBusArbiter</code>：</p>
<pre><code class="language-verilog">    /**
     * TODO (Lab2) replace mux with your own arbiter :)
     */
    CBusArbiter mux(
        .ireqs({icreq, dcreq}),
        .iresps({icresp, dcresp}),
        .*
    );
</code></pre>
<p><code>CBusArbiter</code> 有一个缺点，它需要花费一个时钟周期来确定谁有总线的访问权，无论是有多个请求还是只有一个请求。换句话说，<code>CBusArbiter</code> 会把所有的访存增加至少一个周期的延时。实际上这一个时钟周期可以被优化掉，只是这么做是要付出代价的。因为这种优化需要添加新的组合逻辑，有可能会增加关键路径的延时，导致 CPU 频率降低。</p>
<p>如果你想优化 <code>CBusArbiter</code>，请在 <code>source/mycpu/MyArbiter.sv</code> 中实现新的仲裁器，然后将 <code>VTop</code> 的 <code>CBusArbiter mux</code> 换成 <code>MyArbiter mux</code>。</p>
<p>另外请注意：<strong><code>CBusArbiter</code> 默认的仲裁策略是 DBus 比 IBus 优先</strong>。如果你想调换优先级，请将上面 <code>CBusArbiter mux</code> 接口中的 <code>icreq</code> 和 <code>dcreq</code> 对换，以及将 <code>icresp</code> 和 <code>dcresp</code> 对换。</p>
<h3 id="实现新的指令"><a class="header" href="#实现新的指令">实现新的指令</a></h3>
<p><a href="arch-lab/../misc/instruction.html">“指令列表”</a> 中有一张表，记录了 <code>test1</code> 到 <code>test4</code> 和所有性能测试会用到的指令。请据此确定 <code>test2</code> 需要添加的指令并实现。</p>
<p><code>test2</code> 中需要额外实现的指令，主要有以下三类：</p>
<ul>
<li>更多种类的分支跳转。</li>
<li>引入了以半字（16 位）和字节（8 位）为粒度的内存读写。
<ul>
<li>注意调整总线请求的 <code>size</code> 部分，以及处理读写的数据。</li>
</ul>
</li>
<li>移位的偏移量为寄存器数据。</li>
</ul>
<h3 id="接入-verilator"><a class="header" href="#接入-verilator">接入 Verilator</a></h3>
<p>下一轮实验会使用 Verilator 做模块级测试。本次实验先用 <code>test1</code> 和 <code>test2</code>，方便大家熟悉 Verilator 仿真的流程。</p>
<p>我们提供的测试框架里面，Vivado 仿真的顶层是 <code>mycpu_top</code>，而 Verilator 仿真的顶层用的通常是字母 <code>V</code> 开头的模块<sup class="footnote-reference"><a href="#vtop">1</a></sup>（如 <code>VTop</code>、<code>VCacheTop</code>）。每一个顶层模块对应一个目标名称，也就是 <code>make vsim</code> 命令的 <code>TARGET</code> 参数。如果想以 <code>source/mycpu/VTop.sv</code> 这个文件作为顶层模块，其对应的 <code>TARGET</code> 就是 <code>mycpu/VTop</code>。</p>
<p>测试框架的代码放在 <code>verilate/source</code> 和 <code>verilate/include</code> 两个目录下。不同的顶层模块可能需要不同的测试代码，这些代码会分别放在 <code>verilate/source</code> 中对应子目录里面。如果 <code>TARGET</code> 是 <code>mycpu/VTop</code>，那么其专用的测试代码都放在 <code>verilate/source/mycpu/VTop</code> 下。我们提供了大部分 <code>mycpu/VTop</code> 的测试代码，目前这个目录下有：</p>
<ul>
<li><code>defs.h</code>：一些类型定义。</li>
<li><code>mycpu.h</code>：verilated 模型类的声明。</li>
<li><code>mycpu.cpp</code>：verilated 模型类的实现。</li>
<li><code>vmain.cpp</code>：仿真程序 <code>vmain</code> 的程序入口的代码。</li>
</ul>
<p>所谓 verilated 模型是指把 SystemVerilog 描述的模块翻译成 C++ 代码后的一个 <code>class</code>。翻译后的 verilated 模型再和测试框架一起编译成可执行文件 <code>vmain</code> 后，运行 <code>vmain</code> 就会开始正式的仿真。</p>
<p>运行龙芯杯的 <code>test1</code> 和 <code>test2</code> 需要支持 trace 比对。你需要将 <code>debug_*</code> 信号暴露给 verilated 模型。以 writeback 阶段的 PC 为例，假设某个 CPU 结构如下面的代码所示：</p>
<pre><code class="language-verilog">module Writeback;
    logic [31:0] pc;
endmodule

module MyCore;
    Writeback wb;
endmodule

module VTop;
    MyCore core;
endmodule
</code></pre>
<p>当 <code>VTop</code> 是顶层模块时，从 <code>VTop</code> 访问 PC 的跨模块引用应该写成 <code>core.wb.pc</code>。为了能在 Verilator 中访问到这个信号，首先你需要将 <code>pc</code> 声明为公开的：</p>
<pre><code class="language-verilog">module Writeback;
    logic [31:0] pc /* verilator public_flat_rd */;
endmodule
</code></pre>
<p><code>/* verilator public_flat_rd */</code> 是一条 metacomment。其中 <code>public</code> 表示信号对外可访问，<code>flat</code> 表示信号名会被去层次化（flatten），<code>rd</code> 表示只读（read-only）。去层次化意思是 <code>core.wb.pc</code> 这个信号在翻译后的 C++ 代码中会以一个普通变量的方式呈现给 verilated 模型。C/C++ 的变量名里面不能有 “<code>.</code>”，因此 Verilator 会把 <code>core.wb.pc</code> 转换成 <code>core__DOT__wb__DOT__pc</code>。之后你需要修改 <code>verilate/source/mycpu/VTop</code> 文件夹中的 <code>mycpu.cpp</code>：</p>
<pre><code class="language-c++">auto MyCPU::get_writeback_pc() const -&gt; addr_t {
    /**
     * TODO (Lab2) retrieve PC from verilated model :)
     */
    return VTop-&gt;core__DOT__wb__DOT__pc;  // 访问 PC
}
</code></pre>
<p>这里 <code>VTop</code> 是指向顶层模块的作用域（scope）的指针，由 Verilator 自动生成。用 <code>VTop</code> 可以访问到先前模块内部公开的信号。当 C++ 代码调用上面这个函数时，就会返回当前 <code>core.wb.pc</code> 的值<sup class="footnote-reference"><a href="#pc-type">2</a></sup>。你还需要实现另外 3 个类似的函数。</p>
<p>之后在仓库根目录下运行：</p>
<pre><code class="language-shell">make vsim TARGET=mycpu/VTop TEST=test1 -j
</code></pre>
<p>将会运行 <code>test1</code>。把 <code>TEST=test1</code> 换成 <code>TEST=test2</code> 就会运行 <code>test2</code>。<code>test1</code> 会输出以下内容：</p>
<pre><code class="language-plaintext">./build/gcc/mycpu/VTop/vmain -m misc/nscscc/test1.coe -r misc/nscscc/test1.txt
(info) #1 completed.
(info) #2 completed.
(info) #3 completed.
(info) #4 completed.
(info) #5 completed.
(info) #6 completed.
(info) #7 completed.
(info) #8 completed.
(info) #9 completed.
(info) #10 completed.
(info) #11 completed.
(info) #12 completed.
(info) #13 completed.
(info) #14 completed.
(info) #15 completed.
(info) #16 completed.
(info) #17 completed.
(info) #18 completed.
(info) #19 completed.
(info) #20 completed.
(info) #21 completed.
(info) #22 completed.
(info) #23 completed.
(info) #24 completed.
(info) #25 completed.
(info) #26 completed.
(info) #27 completed.
(info) testbench finished in 337516 cycles (601.973 KHz).
</code></pre>
<h3 id="随机延时"><a class="header" href="#随机延时">随机延时</a></h3>
<p><code>vmain</code> 默认情况下并没有随机延时。可以使用 <code>--p-disable</code>/<code>-p</code> 参数开启随机延时。这个参数是一个概率值，表示内存每个周期无响应的概率。例如：</p>
<pre><code class="language-shell">make vsim -j TARGET=mycpu/VTop TEST=test1 VSIM_ARGS='-p 0.99'
</code></pre>
<p>表示内存有 99% 的时间没有响应。如果设置为 <code>-p 0</code>，相当于关闭随机延时。</p>
<h3 id="记录波形图"><a class="header" href="#记录波形图">记录波形图</a></h3>
<p>如果你不幸没有通过 <code>vmain</code> 的测试，看到了类似于下面的报错：</p>
<pre><code class="language-plaintext">TextDiff: on line 18:
	expect: &quot;1 9fc03be0 10 00000001&quot;
	   got: &quot;1 9fc05100 10 00000001&quot;
make: *** [verilate/Makefile.vsim.mk:123: vsim] Aborted (core dumped)
</code></pre>
<p>这是 trace 比对出错。你可能需要使用波形图来调试。为了加速仿真，<code>make vsim</code> 默认不会记录波形图。使用 <code>--fst-trace</code>/<code>-f</code> 参数开启波形图记录并且指定波形图文件保存的位置。例如：</p>
<pre><code class="language-shell">make vsim TARGET=mycpu/VTop TEST=test1 -j VSIM_ARGS=&quot;-f build/trace.fst&quot;
</code></pre>
<p>将会把波形图保存到 <code>build</code> 目录下的 <code>trace.fst</code>。仿真成功运行或者中途失败退出时，会保存 FST 波形图，并且能在终端输出看到一行信息：</p>
<pre><code class="language-plaintext">FST trace: stop @558950
</code></pre>
<p>FST 格式的波形图文件需要用 GTKWave 打开：</p>
<pre><code class="language-shell">gtkwave build/trace.fst
</code></pre>
<p>你需要自行摸索 GTKWave 的使用方式。我们提供了一份简短的使用说明：<a href="arch-lab/../misc/gtkwave.html">“使用 GTKWave”</a>。</p>
<p>如果遇到你无法确定原因的错误，例如 assertion failed、segmentation fault 之类，有可能是测试框架的问题。请及时向助教反馈。如果遇到这些错误时，终端/命令行最后输出了 “<code>(core dumped)</code>”（上面 trace 比对出错的输出就有），说明这个错误可以使用 <code>coredumpctl gdb</code> 启动 GDB 查看。请进入 GDB 输入 <code>backtrace</code> 后回车，将调用栈打印出来，然后连同调用栈和错误信息一起反馈给助教。</p>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p>总结一下实验 2a 要做的事情：</p>
<ul>
<li>修改取指和访存阶段的逻辑，支持多周期访存。
<ul>
<li>在 Vivado 仿真中通过 <code>test1</code>。</li>
</ul>
</li>
<li>*在 <code>MyArbiter.sv</code> 中实现仲裁器。</li>
<li>根据 <a href="arch-lab/../misc/instruction.html">“指令列表”</a> 添加新的指令。
<ul>
<li>在 Vivado 仿真中通过 <code>test2</code>。</li>
</ul>
</li>
<li>修改 <code>verilate/source/mycpu/VTop</code> 下的 C++ 代码。
<ul>
<li>在 Verilator 仿真中通过 <code>test1</code> 和 <code>test2</code>。</li>
</ul>
</li>
<li>通过 <code>test1</code> 和 <code>test2</code> 上板测试。</li>
</ul>
<p>以上是我们推荐的完成顺序。</p>
<h2 id="实验提交"><a class="header" href="#实验提交">实验提交</a></h2>
<p><strong>本实验和实验 2b 一起提交。</strong></p>
<pre><code class="language-plaintext">18307130024/
├── report/   （报告所在目录）
├── source/   （源文件所在目录）
└── verilate/ （仿真代码所在目录）
</code></pre>
<p>用 <code>zip -r 18307130024.zip 18307130024/</code> 打包。用 <code>unzip 18307130024.zip</code> 检查，应在当前目录下有学号目录。</p>
<h3 id="通过标准"><a class="header" href="#通过标准">通过标准</a></h3>
<ul>
<li>通过以下四条命令的测试：
<ul>
<li><code>make vsim -j TARGET=mycpu/VTop TEST=test1</code></li>
<li><code>make vsim -j TARGET=mycpu/VTop TEST=test1 VSIM_ARGS=&quot;-p 0.99&quot;</code></li>
<li><code>make vsim -j TARGET=mycpu/VTop TEST=test2</code></li>
<li><code>make vsim -j TARGET=mycpu/VTop TEST=test2 VSIM_ARGS=&quot;-p 0.99&quot;</code></li>
</ul>
</li>
<li>上板通过 <code>test1</code> 和 <code>test2</code>。</li>
</ul>
<h3 id="实验报告要求"><a class="header" href="#实验报告要求">实验报告要求</a></h3>
<ul>
<li>格式：PDF</li>
<li>内容：简要记录你所做的修改。写好姓名学号。附上测试通过时的照片或截图。</li>
</ul>
<h3 id="截止时间"><a class="header" href="#截止时间">截止时间</a></h3>
<p><strong>2021 年 4 月 11 日 23:59:59</strong></p>
<h2 id="思考题"><a class="header" href="#思考题">*思考题</a></h2>
<ol>
<li>
<p>张三在 <code>source/util/CBusMultiplexer.sv</code> 中实现了自己的仲裁器，然而过不了仿真。请指出 <code>CBusMultiplexer</code> 存在的问题。</p>
</li>
<li>
<p>龙芯杯的测试框架中有一个叫做 CONFREG 的模块<sup class="footnote-reference"><a href="#confreg">3</a></sup>，用来控制 FPGA 上的各种硬件资源，例如 LED 数码管、按钮。CONFREG 是一个 memory-mapped 设备。其中地址 <code>0xbfaffff0</code> 是一个简化的 UART 打印接口，往这个地址写入 ASCII 码就可在仿真中输出文字。特别的，如果写入的值是 <code>0xff</code>，就会立即停止仿真。</p>
<p>李四写了一段汇编程序 <code>hello.s</code>，放在 <code>misc/hello</code> 目录下，它会打印 “Hello, world!”。但是李四买不起 CPU。请尝试将这段汇编代码编译成 <code>.coe</code> 文件，然后使用</p>
<pre><code class="language-shell">make vsim -j TARGET=mycpu/VTop VSIM_ARGS=&quot;-m [.coe 文件路径]&quot;
</code></pre>
<p>在你的 CPU 上运行这个程序。如果没有出错，<code>vmain</code> 最后会输出：</p>
<pre><code class="language-plaintext">./build/gcc/mycpu/VTop/vmain -m misc/hello/hello.coe
Hello, world!
(info) testbench finished in 652 cycles (515.101 KHz).
</code></pre>
<p>至此，你<del>李四</del>可以尝试在你的 CPU 上运行更加复杂的程序了。</p>
</li>
<li>
<p>王五最近学习了 AXI 总线协议。AXI 是一个双向握手协议。王五推荐你阅读 <a href="arch-lab/../misc/external.html#soc-%E9%83%A8%E5%88%86">“<i class="fa fa-file-pdf-o"></i> AMBA AXI Protocol Specification v1.0”</a>，希望你能了解并总结 AXI 总线的工作方式。</p>
</li>
</ol>
<hr />
<div class="footnote-definition" id="vtop"><sup class="footnote-definition-label">1</sup>
<p><code>VTop</code> 用的是将在实验 3a 中介绍的 CBus（cache bus），是 AXI 总线的简化。Verilator 仿真的顶层模块和 Vivado 中不同的原因之一就是 CBus 模拟起来简单一些 <code>:)</code></p>
</div>
<div class="footnote-definition" id="pc-type"><sup class="footnote-definition-label">2</sup>
<p>类型是 32 位的 <code>uint32_t</code>。</p>
</div>
<div class="footnote-definition" id="confreg"><sup class="footnote-definition-label">3</sup>
<p>我们猜测这是 “configuration registers” 的缩写。</p>
</div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-2b乘除法指令"><a class="header" href="#实验-2b乘除法指令">实验 2b：乘除法指令</a></h1>
<p>增加乘除法指令和 <code>HI</code>、<code>LO</code> 寄存器，上板通过 <code>test3</code> 的测试。请自行翻阅<a href="arch-lab/../misc/instruction.html">指令列表</a>和 <a href="arch-lab/../misc/external.html#mips-%E6%9E%B6%E6%9E%84">MIPS 指令手册</a>。</p>
<h2 id="基本实现"><a class="header" href="#基本实现">基本实现</a></h2>
<p>两个 32 位数相乘的结果是 64 位，相除的结果包括 32 位商和 32 位余数。</p>
<p>MIPS 引入两个新的 32 位寄存器：<code>HI</code> 和 <code>LO</code> 来存储这 64 位结果。</p>
<p>这两个的寄存器写法和通用寄存器类似：</p>
<pre><code class="language-verilog">module hilo (
    input logic clk,
	output i32 hi, lo,
    input i1 hi_write, lo_write,
    input i32 hi_data, lo_data
);
    i32 hi_new, lo_new;
    always_comb begin
        {hi_new, lo_new} = {hi, lo};
        if (hi_write) begin
            hi_new = hi_data;
        end
        if (lo_write) begin
            lo_new = lo_data;
        end
    end
    always_ff @(posedge clk) begin
        {hi, lo} &lt;= {hi_new, lo_new};
    end
endmodule
</code></pre>
<p>以下是单周期乘除法器的一个参考写法：</p>
<pre><code class="language-verilog">module mult (
    input i32 a, b,
    input decoded_op_t op,
    output i32 hi, lo
);
    i64 ans;
    always_comb begin
        case (op)
            MULTU: begin
                ans = {32'b0, a} * {32'b0, b};
                hi = ans[63:32]; lo = ans[31:0];
            end
            MULT: begin
                ans = signed'({{32{a[31]}}, a}) * signed'({{32{b[31]}}, b});
                hi = ans[63:32]; lo = ans[31:0];
            end
            DIVU: begin
                ans = '0;
                lo = {1'b0, a} / {1'b0, b};
                hi = {1'b0, a} % {1'b0, b};
            end
            DIV: begin
                ans = '0;
                lo = signed'(a) / signed'(b);
                hi = signed'(a) % signed'(b);
            end
            default: begin
                {hi, lo, ans} = '0;
            end
        endcase
    end
endmodule
</code></pre>
<h2 id="多周期乘除法器"><a class="header" href="#多周期乘除法器">*多周期乘除法器</a></h2>
<blockquote>
<p>参见：“Computer Architecture: A Quantitative Approach (6th Edition)”: Appendix J</p>
</blockquote>
<p>32 位乘除法器的逻辑十分复杂，其单周期的实现延迟极高。</p>
<p>RefCPU 采用了单周期乘除法器。打开 <code>test5</code> 的 Vivado 工程 → 添加源文件 → “Run Implemented Design” → “Open Implemented Design”，查看延迟最高的一条路径，可得到下图中的信息：</p>
<p><img src="arch-lab/../asset/lab2/div_path.png" alt="div_path" /></p>
<p>延迟最高的几条路径的终点都是 <code>HI</code> 和 <code>LO</code> 寄存器。这是除法操作的数据路径，逻辑级数高达 300，延迟高达 100ns，这就把 CPU 的频率限制在了 10MHz 以下。</p>
<p>实现乘除法器前，我们的五级流水线大概可达到 80MHz（关键路径的延迟约为 12ns）。如此大幅度的频率下滑，难以令人满意。我们已经划分了单周期 CPU 的数据通路（通过流水线），现在我们来划分一下乘法器和除法器，让单条乘除法指令在多个周期里执行。</p>
<p>让乘除法在多个周期里完成，会影响 IPC，但乘除法指令出现的频率很低，总体 IPC 的变化很小。而频率的下降会影响每条指令的执行效率。以下是一个简单的性能分析：</p>
<blockquote>
<p>某程序有 500 条指令（无分支跳转），其中 10 条是除法指令，其余指令的数据通路延迟都很低。</p>
<ul>
<li>
<p>使用单周期除法器的 CPU，时钟周期为 100ns，运行这个程序需要约 500 个周期，即 50,000ns。</p>
</li>
<li>
<p>使用多周期除法器的 CPU，时钟周期为 12ns，除法指令需要 50 个周期执行，运行这个程序需要约 1000 个周期，即 12,000ns。</p>
</li>
</ul>
</blockquote>
<h3 id="乘法器"><a class="header" href="#乘法器">乘法器</a></h3>
<p>一种借用了竖式乘法的单周期乘法器（参考书 J.2 章节），实现如下：</p>
<pre><code class="language-verilog">module multiplier_singlecycle (
	input i32 a, b,
    output i64 c // c = a * b
);
    i65 p;
    always_comb begin
        p[31:0] = a;
        p[64:32] = '0;
        for (int i = 0; i &lt; 32; i++) begin
            if (p[0]) begin // 每次循环扫a的一位
                p[64:32] = p[63:32] + b; // 如果是1则加上b
                // p[64:32] = p[64:32] + b; 更快
            end
            p = {1'b0, p[64:1]}; // 整体右移，需要检查的下一位被移至p[0]
        end
    end
    assign c = p[63:0];
endmodule
</code></pre>
<p>这种方法的延迟约为 60ns。用注释里的那句语句，延迟约为 47ns（注释里的是 33 位加法，为什么比用 32 位加法更快？）。用乘法运算符实现单周期乘法时，Vivado 会调用实验板上的特殊运算资源 DSP，延迟约为 10ns。</p>
<p>这种方法有<strong>每一步</strong>的概念，可以很方便地拆分成多周期：每个时钟周期执行 1 次（或更多次）循环即可。另外，多周期乘法器需要一个计数器，记录乘法已进行的周期数。</p>
<pre><code class="language-verilog">module multiplier_multicycle_from_single (
    input logic clk, resetn, valid,
	input i32 a, b,
    output logic done, // 握手信号，done 上升沿时的输出是有效的
    output i64 c // c = a * b
);
    enum i1 { INIT, DOING } state, state_nxt;
    i35 count, count_nxt;
    localparam i35 MULT_DELAY = {'0, 1'b1, 32'b0};
    always_ff @(posedge clk) begin
        if (~resetn) begin
            {state, count} &lt;= '0;
        end else begin
            {state, count} &lt;= {state_nxt, count_nxt};
        end
    end
    assign done = (state_nxt == INIT);
    always_comb begin
        {state_nxt, count_nxt} = {state, count}; // default
        unique case(state)
            INIT: begin
                if (valid) begin
                    state_nxt = DOING;
                    count_nxt = MULT_DELAY;
                end
            end
            DOING: begin
                count_nxt = {1'b0, count_nxt[34:1]};
                if (count_nxt == '0) begin
                    state_nxt = INIT;
                end
            end
        endcase
    end
    i65 p, p_nxt;
    always_comb begin
        p_nxt = p;
        unique case(state)
            INIT: begin
                p_nxt = {'0, a};
            end
            DOING: begin
                if (p_nxt[0]) begin
                    p_nxt[64:32] = p_nxt[63:32] + b;
                    // p_nxt[64:32] = p_nxt[64:32] + b;
            	end
            	p_nxt = {1'b0, p_nxt[64:1]};
            end
        endcase
    end
    always_ff @(posedge clk) begin
        if (~resetn) begin
            p &lt;= '0;
        end else begin
            p &lt;= p_nxt;
        end
    end
    assign c = p[63:0];
endmodule
</code></pre>
<p>本方法延迟约为 3.6ns（一个 32 位加法）。用注释里的那句语句，延迟约为 3ns。如果每周期做 4 次加法，周期数从 32 降至 8，延迟增加至 7.8ns。</p>
<p>本方法使用了 32 层加法器实现了乘法。如果是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 位无符号数的乘法，本方法使用的加法器层数为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathrm">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。Wallace tree 和 signed-digit tree 是加法器层数为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathrm">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的算法，如果你对此感兴趣，可以查阅参考书 J.9 章节。</p>
<p>然而，我们发现，利用 DSP 资源，单周期乘法的性能已经不错了。如果我们采用 DSP 来实现多周期乘法，很可能两个周期乘法器的延迟就可以令人满意。</p>
<p><img src="arch-lab/../asset/lab2/single_mult_use_dsp_path.png" alt="single_mult_use_dsp_path" /></p>
<p>上图为使用 DSP 资源的单周期乘法器的关键路径。左侧的两个端口很多的元件 <code>DSP48E1</code> 即为 DSP ，右侧的若干 <code>CARRY4</code> 为加法逻辑。每片 <code>DSP48E1</code> 内置一个 25 位乘 18 位的乘法器，集成了乘加 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> 的功能。</p>
<p>如果你想用 DSP 实现乘法器，请查阅 <code>DSP48E1</code> 的有关资料与手册。</p>
<h3 id="除法器"><a class="header" href="#除法器">除法器</a></h3>
<p>一种借用了竖式除法的单周期除法器（参考书 J.2 章节），实现如下：</p>
<pre><code class="language-verilog">module divider_singlecycle (
	input i32 a, b,
    output i64 c // c = {a % b, a / b}
);
    i64 p;
    always_comb begin
        p = {'0, a};
        for (int i = 0; i &lt; 32; i++) begin
            p = {p[63:0], 1'b0};
            if (p[63:32] &gt;= b) begin
                p[63:32] -= b;
                p[0] = 1'b1;
            end
        end
    end

    assign c = p;
endmodule
</code></pre>
<p>本方法延迟约为 93ns（直接用除法运算符的单周期除法器延迟约为 80ns）。</p>
<p>类似地，可以将它拆分成多周期：</p>
<pre><code class="language-verilog">module divider_multicycle_from_single (
    input logic clk, resetn, valid,
	input i32 a, b,
    output logic done,
    output i64 c // c = {a % b, a / b}
);
    enum i1 { INIT, DOING } state, state_nxt;
    i35 count, count_nxt;
    localparam i35 DIV_DELAY = {'0, 1'b1, 32'b0};
    always_ff @(posedge clk) begin
        if (~resetn) begin
            {state, count} &lt;= '0;
        end else begin
            {state, count} &lt;= {state_nxt, count_nxt};
        end
    end
    assign done = (state_nxt == INIT);
    always_comb begin
        {state_nxt, count_nxt} = {state, count}; // default
        unique case(state)
            INIT: begin
                if (valid) begin
                    state_nxt = DOING;
                    count_nxt = DIV_DELAY;
                end
            end
            DOING: begin
                count_nxt = {1'b0, count_nxt[34:1]};
                if (count_nxt == '0) begin
                    state_nxt = INIT;
                end
            end
        endcase
    end
    i64 p, p_nxt;
    always_comb begin
        p_nxt = p;
        unique case(state)
            INIT: begin
                p_nxt = {'0, a};
            end
            DOING: begin
                p_nxt = {p_nxt[63:0], 1'b0};
                if (p_nxt[63:32] &gt;= b) begin
                    p_nxt[63:32] -= b;
                    p_nxt[0] = 1'b1;
                end
            end
        endcase
    end
    always_ff @(posedge clk) begin
        if (~resetn) begin
            p &lt;= '0;
        end else begin
            p &lt;= p_nxt;
        end
    end
    assign c = p;
endmodule
</code></pre>
<p>本方法延迟约为 3.6ns ，周期数为 32。</p>
<h3 id="有符号数的处理"><a class="header" href="#有符号数的处理">有符号数的处理</a></h3>
<p>上面提到的所有实现，都是针对无符号数的，没有考虑有符号数的符号位。</p>
<p>对于有符号数的乘除法，一种简单的处理方法是将有符号数取绝对值，再进行乘除法，最后再恢复符号位，这样就可以复用无符号数的乘除法器了。</p>
<p>乘法的转换比较简单，这里仅举一个例子：当 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>。</p>
<p>除法的处理复杂一些：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h3 id="流水线控制逻辑"><a class="header" href="#流水线控制逻辑">流水线控制逻辑</a></h3>
<p>如果你采用了多周期的乘除法器，那么你需要在流水线的控制逻辑里，添加新的阻塞条件。</p>
<p>一个简单的实现是，遇到乘除法指令时，阻塞流水线至其计算完毕。</p>
<p>MIPS 将乘除法指令的结果写入 <code>HI</code> 和 <code>LO</code> 寄存器，而非通用寄存器，并通过 <code>MFLO</code> 和 <code>MFHI</code> 来读取结果到通用寄存器内。编译器有时会在乘除法指令后插入几条不相关的普通指令，再用 <code>MFLO</code> 和 <code>MFHI</code> 来读取结果。这样，在计算乘除法结果的这几个周期里，流水线可以继续执行；遇到接下来的第一条 <code>MFLO</code> 或 <code>MFHI</code> 时，如果没计算完毕，再阻塞；如果已计算完毕，就直接读取结果，相当于乘除法指令没有造成任何阻塞。这是一种潜在的优化，优化的效果取决于编译器。</p>
<h2 id="实验提交-1"><a class="header" href="#实验提交-1">实验提交</a></h2>
<p><strong>本实验和实验 2a 一起提交。</strong></p>
<h3 id="截止时间-1"><a class="header" href="#截止时间-1">截止时间</a></h3>
<p><strong>2021 年 4 月 11 日 23:59:59</strong></p>
<h2 id="思考题-1"><a class="header" href="#思考题-1">*思考题</a></h2>
<ol>
<li>
<p>李四发现 Verilator 仿真的 CONFREG 模块提供了简单的串口交互接口：地址 <code>0xbfaf1000</code> 用于在串口上读写字符，地址 <code>0xbfaf1014</code> 用于检查是否有未读入的字符。于是李四在 <code>misc/echo</code> 下编写了一个汇编程序 <code>echo.s</code>，它会把你在终端上输入的字符显示出来。请先尝试将 <code>echo.s</code> 编译成 <code>.coe</code> 文件。</p>
<p>打开一个终端，在仓库根目录下运行 <code>make vpty</code>。这个命令会使用 <code>socat</code> 在 <code>build</code> 目录下创建一个虚拟控制台（pty）。然后再打开一个终端，运行：</p>
<pre><code class="language-shell">make vsim -j TARGET=mycpu/VTop VSIM_ARGS=&quot;-m [.coe 文件路径]&quot;
</code></pre>
<p>此时 <code>vmain</code> 会自动接入到之前 <code>make vpty</code> 创建的虚拟控制台的一端，并且会在仿真的终端打印一行 “<code>CONFREG: connected to pty &quot;build/vpty&quot;.</code>”。最后再打开一个终端，运行串口软件。以 GNU <code>screen</code> 为例：</p>
<pre><code class="language-shell">screen build/pty
</code></pre>
<p>然后尝试输入字符，你会看到这些字符在串口软件的终端里能显示出来。此时如果杀死 <code>vmain</code> 进程，再到串口软件上输入时，就看不到新输入的字符了。</p>
<p>此时，你<del>李四</del>可以尝试编写在终端上交互的程序了。李四的 <code>echo.s</code> 还不支持 backspace 键，你可以思考一下如何实现 backspace。</p>
<p><strong>提示</strong>：你可以使用 <code>showkey</code> 查看键盘上每个按键对应的 ASCII 码。</p>
</li>
<li>
<p>李四学会了 C 语言，于是他在 <code>misc/greet</code> 目录下写了一份 C 程序 <code>greet.c</code>。这个程序会读入一行文字，比如 “Gromah”，当你按下回车后，程序会在下一行中显示 “Hello, Gromah!”。请尝试将这个程序编译到 <code>.coe</code> 文件，并在你的 CPU 上运行。</p>
</li>
</ol>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-3a高速缓存"><a class="header" href="#实验-3a高速缓存">实验 3a：高速缓存</a></h1>
<p>高速缓存（cache）对于 CPU 性能十分重要。如果没有缓存，流水线做的所有优化都是徒劳的。本次实验需要实现第一级缓存中的数据缓存（L1d）。由于我们的 CPU 的取指和访存的需求基本一致，因此 L1d 可以直接拿来当 L1i 使用。</p>
<p><img src="arch-lab/../asset/lab3/cache-hierarchy.svg" alt="缓存层次" /></p>
<p>上图是目前消费级多核处理器中非常常见的缓存架构。<code>lscpu -C</code> 命令可以列出你的 CPU 上各级缓存的信息：</p>
<pre><code class="language-plaintext">$ lscpu -C
NAME ONE-SIZE ALL-SIZE WAYS TYPE        LEVEL SETS PHY-LINE COHERENCY-SIZE
L1d       32K     128K    8 Data            1   64        1             64
L1i       32K     128K    8 Instruction     1   64        1             64
L2       256K       1M    4 Unified         2 1024        1             64
L3         8M       8M   16 Unified         3 8192        1             64
</code></pre>
<p>缓存是利用程序局部性原理的经典例子。32KiB 的 L1d 和 L1i 足以在龙芯杯的性能测试得到 99% 的缓存命中率。</p>
<h2 id="l1i--l1d"><a class="header" href="#l1i--l1d">L1i &amp; L1d</a></h2>
<p>一级缓存分为指令缓存和数据缓存，分别服务于取指和访存阶段。原则上 L1i 是只读的，并且不会有程序在运行过程中写入新的指令<sup class="footnote-reference"><a href="#jit">1</a></sup>，因此我们不需要考虑两个缓存之间同步的问题。</p>
<h2 id="实现-l1d"><a class="header" href="#实现-l1d">实现 L1d</a></h2>
<p>本次实验要求 L1d 是写分配（write-allocate）以及写回（write-back）缓存。接下来我们将介绍 L1d 的基本结构。</p>
<h3 id="cache-line"><a class="header" href="#cache-line">Cache Line</a></h3>
<p>Cache line 包含一段连续的内存的副本，一般情况下它的大小是一个 2 的幂次，并且起始地址和大小对齐。当缓存从内存中读取出一条 cache line 时，缓存可以利用内存的突发传输特性，从而降低每个字节的平均读取延时。我们使用的 32 位 AXI 总线一般可以支持单次最高 16×4 = 64 字节的突发传输，因此我们也建议你在性能测试中使用大小为 64 字节的 cache line。从 L1i 的角度来看，相当于每条 cache line 放了 16 条指令。</p>
<p>如果选择大小为 64 字节的 cache line，那么内部的偏移量（offset）需要 6 位。对于 L1i，由于指令都是和 4 字节对齐的，因此只需要 4 位。</p>
<p><img src="arch-lab/../asset/lab3/offset.svg" alt="偏移量" /></p>
<p><img src="arch-lab/../asset/lab3/offset-pad.svg" alt="偏移量和 4 字节对齐" /></p>
<h3 id="cache-set"><a class="header" href="#cache-set">Cache Set</a></h3>
<p>前面说的 cache line 是缓存和内存交互的基本单元。缓存将内存视为一大堆 cache line 的集合。之后我们需要考虑如何在缓存中索引 cache line。</p>
<p>最常见的做法是把缓存分为若干个桶，每个桶内可以存放一定数量的 cache line，有点类似于哈希表。这些桶在缓存的术语中叫做 cache set。一般地址中除去 offset 后最低的几位会被拿来当作 cache set 的索引（index）：</p>
<p><img src="arch-lab/../asset/lab3/index-offset.svg" alt="索引和偏移量" /></p>
<p>每个 cache set 内能同时存储的 cache line 条数称为关联度（associativity）。显然关联度至少为 1。常见的关联度有 2、4、8（也就是所谓的 2 路、4 路、8 路缓存）。由于很多的 cache line 会被映射到同一个 cache set 内，我们必须用地址中剩下的位对它们进行区分。这些位通常也称作标签（tag）：</p>
<p><img src="arch-lab/../asset/lab3/tag-index-offset.svg" alt="标签、索引和偏移量" /></p>
<p>当我们索引 cache line 时，通常会在 cache set 内并行地比较 tag。因此，关联度太大会导致缓存中比较器消耗的硬件资源过多，反而会降低缓存性能。</p>
<blockquote>
<p><strong>为什么使用低位作为索引值？</strong></p>
<p>看一个现实生活中的例子：</p>
<img alt="杨浦区某快餐店" src="arch-lab/../asset/lab3/mcdonalds.jpg" width=65% />
<center class="fig-caption">（杨浦区某快餐店的外卖暂存区。右下角应该是数字 “9”）</center>
<p>上图中货架上每个数字下面写着 “订单尾号”。</p>
<p>该快餐店的订单号是按顺序生成的。因此用低位作为索引有助于充分利用货架上的每个隔间。也正因为顺序生成的订单号，所以在一段时间内产生的外卖的订单号的高位都是一样的。如果用高位，就会导致大量的外卖放在同一层内。</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>offset 用于 cache line 内的寻址。</li>
<li>index 用于索引到 cache set。</li>
<li>tag 用于区分同一个 cache set 内不同的 cache line。</li>
</ul>
<h3 id="替换策略"><a class="header" href="#替换策略">替换策略</a></h3>
<p>缓存的大小通常远小于内存的大小，所以一个程序运行过程中所需要用到的所内存大概率不能都放入缓存中。缓存的主要目标是把程序近期会用到的内存全部装入缓存，这些内存通常也称为工作集（working set）。因此，缓存经常需要把不常用的 cache line 从缓存中清出去，为接下来需要访问的 cache line 腾出空间。</p>
<p>举个例子，对于一个 4 路缓存，某个 cache set 已经有 4 条 cache line 了，然后 CPU 访问的下一个地址对应的 cache line 不在缓存中，但也是映射到这个 cache set 的。此时缓存必须把这个 cache set 内已有的某条 cache line 替换掉，从而能够存放新的 cache line。那么此时应该将哪条 cache line 替换出去呢？</p>
<p>想必各位在 ICS 课上已经了解过各种替换策略了，因此这里不会再一一列举。简单来说，如果我们知道程序的访存顺序，那么我们只需要将下次访问时间最晚的 cache line 替换掉即可。这个贪心算法可以证明是最优的。但显然我们无法准确得知程序的行为。LRU 算法和它的各种变种是缓存中常用的替换算法。LRU 在大多数情况下的效果都比较接近最优贪心算法的效果<sup class="footnote-reference"><a href="#lru">2</a></sup>。最原始的 LRU 算法需要维护 cache set 内每条 cache line 的顺序，在硬件上实现可能比较消耗资源，因此出现了一些 LRU 的变种算法。此外，随机替换策略在缓存关联度足够大的时候也有不错的表现。并且随机替换不需要在访存缓存时更新替换算法的状态，也不需要每个 cache set 都存放额外信息。相比于 LRU 系列，随机替换可以节约大量的硬件资源。</p>
<p>本次实验中你可以实现任意的替换策略。</p>
<h3 id="状态机"><a class="header" href="#状态机">状态机</a></h3>
<p>缓存的状态机可以有两种理解：</p>
<ol>
<li>缓存本身是一个大的状态机，下面管着很多的 cache line。</li>
<li>缓存先索引到一个 cache line，然后每条 cache line 都有一个独立的状态机。</li>
</ol>
<p>在我们的实验中，上面两种理解没有太大区别。对于有多个端口且支持并发访问的缓存而言（例如 L2），可能第二种理解更加贴切。</p>
<p>Cache line 有三种基本的状态<sup class="footnote-reference"><a href="#mosei">3</a></sup>：</p>
<ul>
<li>Invalid：无效状态。这条 cache line 还没有被装入任何有效的数据。</li>
<li>Valid：有效状态。这条 cache line 中有数据，且和内存中的内容相同。</li>
<li>Dirty：已被写入状态。这条 cache line 中有数据，但是先前被 CPU 写入了新的数据，导致 cache line 中的内容和内存中对应位置处的内容不一致。</li>
</ul>
<p>这三种状态一般称为稳定状态（stable states）。当然，从 invalid 变到 valid 需要进行一次突发传输，这需要经过多个周期才能完成，因此需要设立额外的过渡状态（transient states）。</p>
<p>你需要设计一个维护每条 cache line 状态的状态机。具体而言，你的状态机至少需要能处理下面几种事件：</p>
<ul>
<li>缓存命中（cache hit）：CPU 发出请求，并且在缓存内找到了对应的处于 valid/dirty 状态的 cache line。</li>
<li>缓存不命中（cache miss）：CPU 发出请求，但是没有找到对应的处于 valid/dirty 状态的 cache line。</li>
<li>读取 cache line：突发传输中返回了新的数据。</li>
<li>写回 cache line：当 dirty 的 cache line 被替换时，需要使用突发传输将整个 cache line 写回到内存中。</li>
</ul>
<h3 id="存储和索引"><a class="header" href="#存储和索引">存储和索引</a></h3>
<p>对于每条 cache line，我们需要存储：</p>
<ul>
<li>cache line 的数据。</li>
<li>cache line 的 tag、状态信息。通常称为元数据（metadata）。</li>
</ul>
<p>对于每个 cache set，你需要存储一个 cache line 的数组。</p>
<p>假设 index 和 offset 都是 6 位，关联度为 4，下面是一个简略的实现：</p>
<pre><code class="language-verilog">typedef i20 tag_t;
typedef i6 index_t;
typedef i6 offset_t;
typedef i2 position_t;  // cache set 内部的下标

typedef struct packed {
    tag_t tag;
    logic valid;  // cache line 是否有效？
    logic dirty;  // cache line 是否被写入了？
} meta_t;
typedef meta_t [3:0] meta_set_t;

typedef word_t [15:0] cache_line_t;
typedef cache_line_t [3:0] cache_set_t;

// 存储单元（寄存器）
meta_set_t [63:0] meta;
cache_set_t [63:0] data;

// 解析地址
tag_t tag;
index_t index;
offset_t offset;
assign {tag, index, offset} = dreq.addr;

// 访问元数据
meta_set_t foo;
assign foo = meta[index];

// 搜索 cache line
position_t position;
always_comb begin
    position = 2'b00;  // 防止出现锁存器

    unique if (foo[0].tag == tag)
        position = 2'b00;
    else if (foo[1].tag == tag)
        position = 2'b01;
    else if (foo[2].tag == tag)
        position = 2'b10;
    else if (foo[3].tag == tag)
        position = 2'b11;
end

// 访问 cache line
cache_line_t bar;
assign bar = data[index][position];
assign dreq.data = bar[offset[5:2]];  // 4 字节对齐
</code></pre>
<p>针对缓存的实现，我们有如下的建议：</p>
<ul>
<li>
<p><strong>实现参数化</strong>。主要是为了方便修改缓存的大小。你可以在 <code>DCache</code> 模块的声明处添加自定义的参数，例如：</p>
<pre><code class="language-verilog">module DCache #(
    parameter int OFFSET_BITS = 4,
    parameter int INDEX_BITS = 2,

    localparam int TAG_BITS = 32 - OFFSET_BITS - INDEX_BITS
) (
    // 接口列表
);
</code></pre>
<p>上面的 <code>parameter</code> 是外部可以改动的参数，例如</p>
<pre><code class="language-verilog">DCache #(.OFFSET_BITS(6)) dcache_inst(.*);
</code></pre>
<p>而 <code>localparam</code> 仅限模块内部使用，类似于常量值（比如 C++ 中的 <code>constexpr</code>）。</p>
</li>
<li>
<p><strong>强烈建议初次调试时不要使用太大的缓存</strong>。我们推荐最开始调试的时候使用 4 位的 offset 和 2 位的 index，并且关联度不要超过 4。这相当于每条 cache line 存储 4 条指令，缓存中只有 4 个 cache set。过长的 cache line 会让突发传输的过程太长，而过多的 cache set 和过大的关联度会增加在缓存中寻找问题的难度。一般 4 个足以测试出绝大部分的问题。</p>
</li>
<li>
<p>*使用 LUTRAM 存储 cache line。我们在 <code>source/ram</code> 目录下提供了 <code>LUTRAM.sv</code> 和 <code>LUTRAMTest.sv</code>，它们分别是 LUTRAM IP 核的封装和测试<sup class="footnote-reference"><a href="#bram">4</a></sup>。使用 LUTRAM 可以大幅减少你的缓存消耗的硬件资源。你可以在 Vivado 中观察 <code>LUTRAMTest.sv</code> 的仿真波形图，或者是阅读 <code>LUTRAM.sv</code> 内的行为级模型的 SystemVerilog 代码，来了解 LUTRAM 的行为。我们也提供了 <code>source/refcpu/StupidBuffer.sv</code> 作为使用 LUTRAM 的示例。</p>
</li>
</ul>
<h2 id="接口"><a class="header" href="#接口">接口</a></h2>
<p>缓存是放在 CPU 流水线和内存之间的，因此：</p>
<ul>
<li>缓存对 CPU 提供一个 DBus 的接口，并且保证缓存是透明（transparent）的。即从 CPU 来看，无论有没有缓存，访存的接口应该都是一致。</li>
<li>缓存在内存这边使用 CBus 接口，方便利用突发传输。</li>
</ul>
<h3 id="缓存总线cbus"><a class="header" href="#缓存总线cbus">缓存总线（CBus）</a></h3>
<p>CBus 是对 AXI 总线突发传输接口的简化。</p>
<pre><code class="language-verilog">typedef struct packed {
    logic    valid;     // 是否发出请求
    logic    is_write;  // 是否是写请求
    msize_t  size;      // 单次传输的字节数
    addr_t   addr;      // 突发传输起始地址
    strobe_t strobe;    // 单次传输中的写使能信号
    word_t   data;      // 单次传输中的写数据
    mlen_t   len;       // 总传输次数
} cbus_req_t;

typedef struct packed {
    logic  ready;  // 上一次传输是否完成
    logic  last;   // 最后一次传输是否完成
    word_t data;   // 单次传输读取的数据
} cbus_resp_t;
</code></pre>
<p>CBus 的突发传输实际上就是 AXI 总线中的 WRAP 类型的突发传输。在 AXI 总线中，每次突发传输称为一次事务（transaction）。事务内可以有多次数据传输的总线握手（burst）。</p>
<p>事务有几个基本属性：</p>
<ul>
<li>是否有效：<code>valid</code> 为 1 表明事务有效。</li>
<li>写事务/读事务：由 <code>is_write</code> 决定。</li>
<li>单次读写大小：由 <code>size</code> 决定。可以为 <code>MSIZE1</code>（单字节）、<code>MSIZE2</code>（双字节）或者 <code>MSIZE4</code>（4 字节）。</li>
<li>起始地址：由 <code>addr</code> 给出。</li>
<li>总传输/握手次数：由 <code>len</code> 给出。可以为 <code>MLEN1</code>、<code>MLEN2</code>、<code>MLEN4</code>、<code>MLEN8</code> 和 <code>MLEN16</code> 中的一种。</li>
</ul>
<p><strong>以上 5 项作为事务的属性，在事务进行中是不能变更的</strong>。</p>
<p>和 DBus 类似，CBus 的握手也是在时钟周期上升沿时进行的。其中 <code>ready</code> 为 1 表示操作完成，而 <code>last</code> 为 1 表明这是这个事务中最后一次握手。当 <code>last</code> 为 1 的握手完成之后，如果接下来没有其它事务需要进行了，那么 <code>valid</code> 应该设为 0。当然你是知道总共会做多少次传输的，所以 <code>last</code> 可以换成你自己的计数器。</p>
<p>前面还剩下 <code>strobe</code> 和 <code>data</code> 两个信号没有说明。首先，这两个信号和 DBus 中类似，也相当于有 4 个 byte lane，这里就不再赘述。其次，这两个信号是单次传输时用到的信号，因此在事务进行过程中可以变动。每当 <code>ready</code> 信号握手成功后，<code>strobe</code> 和 <code>data</code> 就应该换成下一次传输的数据。你可能注意到 <code>addr</code> 在这个过程中是不变的，这是因为每次传输时的具体位置 <code>real_addr</code> 是从 <code>addr</code> 开始累加的，即每次传输成功后，<code>real_addr</code> 加上 <code>size</code>。此外，由于我们用的是 WRAP 类型的传输，所以事务传输的范围是和 <code>size</code>×<code>len</code> 个字节对齐的。例如，当 <code>size</code> 是 <code>MSIZE4</code>，而 <code>len</code> 是 <code>MLEN4</code> 时，会和 4×4 = 16 字节对齐。如果 <code>addr</code> 是 <code>0x1f8</code>，那么 <code>real_addr</code> 将依次为 <code>0x1f8</code>、<code>0x1fc</code>、<code>0x1f0</code> 和 <code>0x1f4</code>。</p>
<p>特别的，AXI 事务传输允许 <code>addr</code> 不用和 <code>size</code> 对齐。此时第一次传输相当于非对齐传输，而之后传输依然会按照对齐的地址进行传输。例如，当 <code>size</code> 是 <code>MSIZE4</code>，而 <code>addr</code> 是 <code>0x1f5</code> 时，<code>real_addr</code> 依次为 <code>0x1f5</code>、<code>0x1f8</code>、<code>0x1fc</code>...</p>
<p>下图是一个从地址 <code>0xbfc01fc1</code> 开始连续传输 15 个字节 <code>0x11</code>~<code>0xff</code> 的示例：</p>
<p><img src="arch-lab/../asset/lab3/cbus-transaction.svg" alt="CBus 事务传输" /></p>
<p>上图中，四次握手的实际地址分别为 <code>0xbfc01fc1</code>、<code>0xbfc01fc4</code>、<code>0xbfc01fc8</code> 和 <code>0xbfc01fcc</code>。</p>
<p>在 <code>verilate/include/axi.h</code> 有 AXI WRAP 突发传输的 C++ 描述。</p>
<h3 id="参考实现"><a class="header" href="#参考实现">参考实现</a></h3>
<p><code>source/refcpu/StupidBuffer.sv</code> 是一个参考实现。<code>StupidBuffer</code> 中展示了如何进行突发传输，并且同时将突发传输中的数据保存到 LUTRAM。</p>
<h2 id="模块级测试"><a class="header" href="#模块级测试">模块级测试</a></h2>
<p>本次实验使用 Verilator 对缓存做专门的测试。</p>
<p>与之前不同，这次用了一个新的名为 <code>VCacheTop</code> 的顶层模块，它只接入了缓存，没有带上流水线。同时，测试你的缓存的 C++ 代码也放到了 <code>verilate/source/mycpu/VCacheTop</code> 下面。</p>
<p>用下面的命令运行模块级测试：</p>
<pre><code class="language-shell">make vsim -j TARGET=mycpu/VCacheTop VSIM_OPT=1
</code></pre>
<p>加入 <code>VSIM_OPT=1</code> 的原因是后面的单元测试非常大，不进行编译器优化会非常慢。</p>
<p>如果测试全部通过，最后应该能看到：</p>
<pre><code class="language-plaintext">(info) 27 tests passed.
</code></pre>
<h3 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h3>
<p>这中间最重要的文件是 <code>verilate/source/refcpu/VCacheTop/tests.inl</code>，这里面包含了本次实验所有的单元测试。<code>mycpu/VCacheTop</code> 文件夹下的 <code>tests.cpp</code> 里面直接 <code>include</code> 了 <code>tests.inl</code>，也就是说我们将用测试 <code>StupidBuffer</code> 的单元测试来测试你的缓存。每个单元测试形如：</p>
<pre><code class="language-c++">// this test is explicitly marked with &quot;SKIP&quot;.
WITH SKIP {
    bool one = 1, three = 3;
    ASSERT(one + one == three);  // trust me, it must fail
    // but you should not fail here since it's skipped.
} AS(&quot;akarin~&quot;);
</code></pre>
<p>可以看到，单元测试的代码用 <code>WITH</code>...<code>AS(&quot;...&quot;)</code> 包起来，<code>AS</code> 后面的字符串是这个单元测试的名字。测试内部使用 <code>ASSERT</code> 检查测试状态。如果状态与预期不符，<code>ASSERT</code> 会直接中断这个测试并报错。此外，<code>WITH</code> 后面可以带上一些插件（plugin），例如上面的 <code>SKIP</code>，表明这个测试会直接跳过。</p>
<p>具体的测试内容需要你自己阅读 <code>tests.inl</code>。</p>
<h3 id="对照测试"><a class="header" href="#对照测试">对照测试</a></h3>
<p>有些测试使用了 <code>CMP_TO</code> 插件，例如：</p>
<pre><code class="language-c++">WITH CMP_TO(ref) {
    for (size_t i = 0; i &lt; CMP_SCAN_SIZE / 4; i++) {
        dbus-&gt;storew(4 * i, randi&lt;uint32_t&gt;());
        dbus-&gt;loadw(4 * i);
    }
} AS(&quot;cmp: word&quot;);
</code></pre>
<p>此时需要你自己编写你的缓存的对照模型（reference model）。所谓对照模型，就是用 C++ 描述你的缓存的各种行为。其中会包含诸如替换策略、内部状态等各种信息。测试框架会在运行 verilated 模型的同时也运行你的对照模型，并且在每次访存操作（load 或者 store）完成后，将对照模型的内部状态和 verilated 模型进行比较，如果不一致就报错（由 <code>CacheRefModel::compare_internal</code> 实现）。并且，在单个测试结束时，也会将对照模型的内存和 verilated 模型中的内存进行比较（由 <code>CacheRefModel::compare_memory</code> 实现）。</p>
<p>你需要将 <code>cache_ref.h</code> 和 <code>cache_ref.cpp</code> 中的所有 <code>TODO</code> 全部实现，然后才能通过这些测试。</p>
<p>请注意：对照模型的仿真不是以时钟周期为单位的，而是以访存操作为单位的。也就是说：</p>
<pre><code class="language-c++">auto CacheRefModel::load(addr_t addr, AXISize size) -&gt; word_t {
    // ...
}
void CacheRefModel::store(addr_t addr, AXISize size, word_t strobe, word_t data) {
    // ...
}
</code></pre>
<p>分别表示向缓存读取和写入的操作，而这两个函数的目标是计算操作完成后，理论上缓存的内部状态是怎么样的。测试框架在向 verilated 模型发送请求并等待 verilated 模型完成后，将先调用对应的函数，然后调用 <code>compare_internal</code> 来检查内部状态。</p>
<h3 id="调试工具"><a class="header" href="#调试工具">调试工具</a></h3>
<p>在单元测试的 <code>WITH</code> 后面加上 <code>TRACE</code>，就会在运行测试的中途记录 FST 波形图。默认会把波形图放在 <code>build</code> 文件夹下面。例如：</p>
<pre><code class="language-c++">WITH TRACE {
    // ...
} AS(&quot;example test 1&quot;);
</code></pre>
<p>将会把波形图记录到 <code>build/example-test-1.fst</code> 这个文件中。</p>
<p>类似的，在 <code>WITH</code> 后面加上 <code>DEBUG</code>，将会在终端打印所有访存操作。对比较小的测试可能有用。</p>
<h3 id="参考实现-1"><a class="header" href="#参考实现-1">参考实现</a></h3>
<p><code>verilate/source/refcpu/VCacheTop</code> 下面有 <code>StupidBuffer</code> 的配套代码。这可能是唯一比较靠谱的参考代码了 <code>:)</code></p>
<h3 id="性能监测"><a class="header" href="#性能监测">*性能监测</a></h3>
<p><code>tests.inl</code> 最后的四个测试分别会在你的缓存上运行 <code>std::sort</code>、<code>std::stable_sort</code>、堆排序和二叉树插入和搜索算法。它们都使用了一个名为 <code>STAT</code> 的插件。此时你需要实现 <code>mycache.h</code> 和 <code>mycache.cpp</code> 下面的所有 TODO，主要是 <code>reset_statistics</code>、<code>update_statistics</code> 和 <code>print_statistics</code> 这三个函数。它们分别表示重置统计信息、更新统计信息和打印统计信息。</p>
<p>你可以在这里统计你的缓存的命中率、突发传输所用周期数等信息。测试框架在每个单元测试开始的时候会调用 <code>reset_statistics</code>；然后在仿真过程中，每个周期都会调用一次 <code>update_statistics</code>；测试结束时，会调用 <code>print_statistics</code> 来打印这个测试的统计信息。<code>StupidBuffer</code> 的配套代码中，实现了 <code>StupidBuffer</code> 各个状态所用周期数的计数器，在测试中会输入如下的内容：</p>
<pre><code class="language-plaintext">&quot;std::sort&quot;: [IDLE]=8441412, [FETCH]=143504004, [READY]=8441412, [FLUSH]=19608616
[OK] std::sort (11921ms)
&quot;std::stable_sort&quot;: [IDLE]=5331138, [FETCH]=90629346, [READY]=5331138, [FLUSH]=2550000
[OK] std::stable_sort (7313ms)
&quot;heap sort&quot;: [IDLE]=5569012, [FETCH]=94673204, [READY]=5569012, [FLUSH]=2550000
[OK] heap sort (7054ms)
&quot;binary search tree&quot;: [IDLE]=7868866, [FETCH]=133770722, [READY]=7868866, [FLUSH]=34292706
[OK] binary search tree (10670ms)
</code></pre>
<h3 id="自定义测试"><a class="header" href="#自定义测试">*自定义测试</a></h3>
<p>如果有需要，你可参照已有的单元测试代码，在 <code>mycpu/VCacheTop/tests.cpp</code> 中编写你自己的单元测试。</p>
<p>如果你尝试对缓存进行优化，你也可以用单元测试来检测优化的效果。</p>
<h3 id="并行测试"><a class="header" href="#并行测试">*并行测试</a></h3>
<p>为了加快测试速度，你可以使用下面的命令：</p>
<pre><code class="language-shell">make vsim -j TARGET=mycpu/VCacheTop VSIM_OPT=1 VSIM_ARGS=&quot;-j4&quot;
</code></pre>
<p>其中 <code>-j4</code> 表示使用 4 个进程一起跑单元测试<sup class="footnote-reference"><a href="#fork">5</a></sup>。</p>
<h2 id="实验提交-2"><a class="header" href="#实验提交-2">实验提交</a></h2>
<p><strong>本次实验和实验 3b 一起提交</strong>。</p>
<pre><code class="language-plaintext">18307130024/
├── report/   （报告所在目录）
├── source/   （源文件所在目录）
└── verilate/ （仿真代码所在目录）
</code></pre>
<p>用 <code>zip -r 18307130024.zip 18307130024/</code> 打包。用 <code>unzip 18307130024.zip</code> 检查，应在当前目录下有学号目录。</p>
<h3 id="通过标准-1"><a class="header" href="#通过标准-1">通过标准</a></h3>
<ul>
<li>通过模块级测试。
<ul>
<li><code>make vsim -j TARGET=mycpu/VCacheTop VSIM_OPT=1</code></li>
<li><code>make vsim -j TARGET=mycpu/VCacheTop VSIM_OPT=1 VSIM_ARGS=&quot;-p 0.5&quot;</code></li>
</ul>
</li>
</ul>
<h3 id="实验报告要求-1"><a class="header" href="#实验报告要求-1">实验报告要求</a></h3>
<ul>
<li>格式：PDF</li>
<li>内容：
<ul>
<li>简要描述你设计的缓存。</li>
<li>如果你尝试做了优化，请举例说明优化的效果。</li>
<li>写好姓名学号。附上测试通过时的照片或截图。</li>
</ul>
</li>
</ul>
<h3 id="截止时间-2"><a class="header" href="#截止时间-2">截止时间</a></h3>
<p><strong>2021 年 5 月 10 日 12:00</strong></p>
<h2 id="思考题-2"><a class="header" href="#思考题-2">*思考题</a></h2>
<ol>
<li>在关联度为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 的缓存中实现 LRU 算法时，每个 cache set 最少需要为 LRU 算法记录多少位的额外信息？</li>
<li>缓存在重置（reset）的时候，除元信息外，是否需要将每条 cache line 内的数据也重置？如果不重置会有什么影响？如果重置又会有什么影响？</li>
<li>模块级测试的最后四个测试使用了 <code>MemoryCell</code>，它表示 verilated 模型中指定地址处的一个小内存单元。所有读写类型为 <code>MemoryCell</code> 的变量的操作都会被重定向到 verilated 模型的仿真上。这样一来就能非常方便地在你的缓存上跑各种算法了。
<ul>
<li>请尝试使用 <code>MemoryCell</code> 编写一个新的单元测试。你可以在这个测试内跑任意算法。</li>
<li><code>MemoryCell</code> 是否真的把所有的访存操作都重定向了？如果是，请说明理由。如果不是，请指出有哪些访存没有被重定向。</li>
<li>你有不同于 <code>MemoryCell</code> 的解决方案吗？</li>
</ul>
</li>
<li>张三发现，在先前 <code>lscpu -C</code> 的例子中，L1i/L1d 的 set 数量（SETS）只有 64，远小于 L2 的 set 数量，但是 L1i/L1d 的关联度（WAYS）是 8，反而比 L2 大。为什么它不选择把 L1i/L1d 的关联度降到 4，并且把 set 数量提高到 128 呢？</li>
<li>文档中 <code>lscpu -C</code> 的输出来自 Intel 的 Coffee Lake 微架构的 i5 8300H。该 CPU 的 L3 是一个 (strictly) inclusive cache<sup class="footnote-reference"><a href="#inclusive">6</a></sup>。结合 <a href="https://en.wikichip.org/wiki/intel/microarchitectures/coffee_lake#Memory_Hierarchy">WikiChip</a> 上的信息，请尝试解释为什么 L3 的关联度是 16。</li>
</ol>
<hr />
<div class="footnote-definition" id="jit"><sup class="footnote-definition-label">1</sup>
<p>但实际上像 JVM、Javascript V8 这种利用 JIT 技术的软件可能会有这种需求。MIPS 架构中提供了 <code>CACHE</code> 指令来解决这个问题。</p>
</div>
<div class="footnote-definition" id="lru"><sup class="footnote-definition-label">2</sup>
<p>如果是在链表上做更新，Sleator &amp; Tarjan 证明了 LRU 算法和最优算法的操作数是同一个级别的：<a href="https://dl.acm.org/doi/10.1145/2786.2793">“Amortized Efficiency of List Update and Paging Rules”</a>。</p>
</div>
<div class="footnote-definition" id="mosei"><sup class="footnote-definition-label">3</sup>
<p>在多核的缓存系统中，由于需要维护缓存一致性，可能会有更多的状态。例如在 MOSEI 缓存一致性协议中，每条 cache line 的状态可能是 Modified、Owner、Shared、Exclusive 或者 Invalid 中的一种。</p>
</div>
<div class="footnote-definition" id="bram"><sup class="footnote-definition-label">4</sup>
<p>你可能发现 <code>source/ram</code> 目录下还有一个 <code>BRAM.sv</code>。我们在本次实验中不推荐你用 BRAM，因为 BRAM 的读写有至少一个周期的延时。</p>
</div>
<div class="footnote-definition" id="fork"><sup class="footnote-definition-label">5</sup>
<p>由于并行测试用到了 <code>fork</code>，所以目前仅支持在 Linux 环境中使用。</p>
</div>
<div class="footnote-definition" id="inclusive"><sup class="footnote-definition-label">6</sup>
<p>参见 <a href="https://en.wikipedia.org/wiki/CPU_cache#INCLUSIVE">Wikipedia</a> 以及网上的资料。</p>
</div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-3b接入流水线"><a class="header" href="#实验-3b接入流水线">实验 3b：接入流水线</a></h1>
<p>无可奉告。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="实验-4"><a class="header" href="#实验-4">实验 4</a></h1>
<p>无可奉告。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="操作系统部分"><a class="header" href="#操作系统部分">操作系统部分</a></h1>
<p>无可奉告。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="挑战课题"><a class="header" href="#挑战课题">挑战课题</a></h1>
<p>TRY YOUR BEST!</p>
<ul>
<li><a href="project/task1.html">方向一</a>：流水线性能优化。</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="方向一流水线性能优化"><a class="header" href="#方向一流水线性能优化">方向一：流水线性能优化</a></h1>
<blockquote>
<p>预备条件：通过 <code>test1</code>、<code>test2</code>、<code>test3</code>；未实现的指令 decode 为 <code>NOP</code>。</p>
</blockquote>
<p>你将升级你的流水线架构，以获取更高的性能。</p>
<h2 id="通过标准-2"><a class="header" href="#通过标准-2">通过标准</a></h2>
<ul>
<li>上板 <code>test1</code>、<code>test2</code>、<code>test3</code> 显示两个绿灯，多次 reset 后仍显示两个绿灯。</li>
<li>上板 <code>test5</code>，时序无违例。</li>
</ul>
<h2 id="评分标准"><a class="header" href="#评分标准">评分标准</a></h2>
<ul>
<li>上板 <code>test5</code>，调整开关以运行十个测试，将七段数码管读数记录在 <code>test5_score.xls</code> 中（已上传至 eLearning），得到综合性能分。</li>
</ul>
<h2 id="操作步骤"><a class="header" href="#操作步骤">操作步骤</a></h2>
<p>打开 <code>test5</code> 的 Vivado 工程，导入源文件后，你可以调整你的时钟频率。</p>
<p><img src="project/../asset/project/frequency.png" alt="frequency" /></p>
<p>在 “IP Sources” 中，打开 <code>clk_pll</code>，点击 “Output Clocks”，修改 <code>cpu_clk</code> 的值（上图红圈的内容）为你期望的时钟频率。除了这个值，该 IP 核的其他信息均不允许修改。</p>
<p>生成 bit 文件后，检查是否出现时序违例：</p>
<p><img src="project/../asset/project/wns.png" alt="wns" /></p>
<p>检查上图红圈的值，不允许为负值。图中是合法值。如果出现负值，请降低你的时钟频率。如果是正值，你可以增加时钟频率，以获得更高的分数。</p>
<blockquote>
<p>TIPS：如果你想知道你的 CPU 合法的最高时钟频率，请将时钟频率调整至一个非常高的值 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>，确保出现时序违例。生成 bit 文件后，假设 WNS 为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal">t</span></span></span></span> ns（<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>），那么可以通过以下公式估算最高时钟频率：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 单位为 MHz, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 单位为 ns。</p>
</blockquote>
<p>上板后，先将所有开关往下调，<strong>并把编号为 7 的开关往上调</strong>。然后，调整右侧的四个开关，让它们表示十进制数 1 到 10（对应十个测试）。</p>
<p><img src="project/../asset/project/score_board.jpg" alt="score_board" /></p>
<p>上图为 RefCPU 在 7MHz 的频率下，右侧四个开关表示十进制数 1 时的上板现象（红框处的编号为 7 的开关向上调）。七段数码管会有一个读数。如果结果为两个绿灯，则将十个测试的读数依次记录到 <code>test5_scoce.xls</code>（文件已上传至 eLearning，在 “<code>实验部分</code>” 目录下）里。如果某个测试的结果为红灯，该项成绩填 0。</p>
<p><img src="project/../asset/project/score_refcpu.png" alt="score_refcpu" /></p>
<p>上图是 RefCPU 在 7MHz 的频率下，10 个测试的读数。填写完读数后，把表格中的时钟频率改成你 CPU 的时钟频率。图中数据所用的 bit 文件已上传至 eLearning，路径为 “<code>实验部分/refcpu_test5.bit</code>”。</p>
<h2 id="提交内容"><a class="header" href="#提交内容">提交内容</a></h2>
<p>待定</p>
<h2 id="截止时间-3"><a class="header" href="#截止时间-3">截止时间</a></h2>
<p>待定</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="附加资料"><a class="header" href="#附加资料">附加资料</a></h1>
<p>这一部分包含一些与实验内容相关的资料。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="外部资料"><a class="header" href="#外部资料">外部资料</a></h1>
<p>这里列举了一些和本学期实验课程以及龙芯杯相关的文档。这些资料不一定都会在本学期的实验中用到。各位同学可以根据自己的需求来翻阅。</p>
<h2 id="mips-架构"><a class="header" href="#mips-架构">MIPS 架构</a></h2>
<ul>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/mips/Volume%20I:%20Introduction%20to%20MIPS32%20Architecture.pdf">Volume I: Introduction to MIPS32 Architecture</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/mips/Volume%20II:%20MIPS32%20Instruction%20Set.pdf">Volume II: MIPS32 Instruction Set</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/mips/Volume%20III:%20MIPS32%20Privileged%20Resource%20Architecture.pdf">Volume III: MIPS32 Privileged Resource Architecture</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/mips/MIPS%20%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81.pdf">MIPS 指令编码</a></li>
</ul>
<h2 id="soc-部分"><a class="header" href="#soc-部分">SoC 部分</a></h2>
<ul>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/soc/AMBA%20AXI%20Protocol%20Specification%20v1.0.pdf">AMBA AXI Protocol Specification v1.0</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/soc/AMBA%20AXI%20and%20ACE%20Protocol%20Specification.pdf">AMBA AXI and ACE Protocol Specification</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/soc/UltraScale%20Architecture%20Libraries%20Guide.pdf">UltraScale Architecture Libraries Guide</a></li>
<li><i class="fa fa-file"></i> <a href="https://github.com/FDUCSLG/ICS-2021Spring-FDU/blob/master/misc/doc/soc/BRAM%20%26%20LUTRAM.md">BRAM &amp; LUTRAM</a></li>
</ul>
<h2 id="2019-年龙芯杯幻灯片"><a class="header" href="#2019-年龙芯杯幻灯片">2019 年龙芯杯幻灯片</a></h2>
<ul>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/slides-2019/1%20-%20%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97.pdf">1 - 参赛指南</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/slides-2019/2%20-%20%E5%A4%A7%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%A7%A3%E8%AF%BB.pdf">2 - 大赛技术方案解读</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/slides-2019/3%20-%20%E5%8A%9F%E8%83%BD%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95%E8%AF%B4%E6%98%8E.pdf">3 - 功能性能测试和调试说明</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/slides-2019/4%20-%20%E6%B1%87%E7%BC%96%E4%B8%8E%20Verilog.pdf">4 - 汇编与 Verilog</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/slides-2019/5%20-%20MIPS%20%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%20CPU%20%E8%AE%BE%E8%AE%A1.pdf">5 - MIPS 指令集与 CPU 设计</a></li>
</ul>
<h2 id="2020-年龙芯杯文档"><a class="header" href="#2020-年龙芯杯文档">2020 年龙芯杯文档</a></h2>
<ul>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A0%20-%20%E5%A4%A7%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%A7%A3%E8%AF%BB.pdf">A0 - 大赛技术方案解读</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A1%20-%20%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97.pdf">A1 - 参赛指南</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A3%20-%20%E2%80%9C%E7%B3%BB%E7%BB%9F%E8%83%BD%E5%8A%9B%E5%9F%B9%E5%85%BB%E5%A4%A7%E8%B5%9B%E2%80%9D%20MIPS%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%A7%84%E8%8C%83.pdf">A3 - “系统能力培养大赛” MIPS 指令系统规范</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A4%20-%20%E9%BE%99%E8%8A%AF%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%95%99%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AE%B1%EF%BC%88Artix-7%EF%BC%89%E4%BB%8B%E7%BB%8D.pdf">A4 - 龙芯体系结构教学实验箱（Artix-7）介绍</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A6%20-%20Vivado%20%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E.pdf">A6 - Vivado 安装说明</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A7%20-%20Vivado%20%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.pdf">A7 - Vivado 使用说明</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A8%20-%20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85.pdf">A8 - 交叉编译工具链安装</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A9%20-%20CPU%20%E4%BB%BF%E7%9C%9F%E8%B0%83%E8%AF%95%E8%AF%B4%E6%98%8E.pdf">A9 - CPU 仿真调试说明</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A10%20-%20FPGA%20%E5%9C%A8%E7%BA%BF%E8%B0%83%E8%AF%95%E8%AF%B4%E6%98%8E.pdf">A10 - FPGA 在线调试说明</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A11%20-%20Trace%20%E6%AF%94%E5%AF%B9%E6%9C%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.pdf">A11 - Trace 比对机制使用说明</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/docs-2020/A12%20-%20%E7%B1%BB%20SRAM%20%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E.pdf">A12 - 类 SRAM 接口说明</a></li>
</ul>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<ul>
<li><i class="fa fa-github"></i> <a href="https://github.com/trivialmips/nontrivial-mips">NonTrivial-MIPS</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="https://riteme.site/nscscc/doc/NSCSCC%202019%20Final%20Report.pdf">NSCSCC 2019 Final Report</a></li>
<li><i class="fa fa-link"></i> <a href="https://gcc.godbolt.org/">Compiler Explorer</a></li>
<li><i class="fa fa-github"></i> <a href="https://github.com/loongson-education/nscscc-wiki">“龙芯杯” 全国大学生计算机系统能力培养大赛信息汇总</a></li>
<li><i class="fa fa-link"></i> <a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator">Verilator Manual</a></li>
<li><i class="fa fa-link"></i> <a href="https://www.xilinx.com/html_docs/xilinx2017_4/sdaccel_doc/odz1504034293215.html">Understanding FPGA Architecture</a></li>
<li><i class="fa fa-file-pdf-o"></i> <a href="http://gtkwave.sourceforge.net/gtkwave.pdf">GTKWave 3.3 Wave Analyzer User’s Guide</a></li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="指令列表"><a class="header" href="#指令列表">指令列表</a></h1>
<p>在下表中，“✓” 表示对应测试中需要这条指令。</p>
<table><thead><tr><th align="center">指令</th><th align="center">test1</th><th align="center">test2</th><th align="center">test3</th><th align="center">test4</th><th align="center">bitcount</th><th align="center">bubble_sort</th><th align="center">coremark</th><th align="center">crc32</th><th align="center">dhrystone</th><th align="center">quick_sort</th><th align="center">select_sort</th><th align="center">sha</th><th align="center">stream_copy</th><th align="center">stringsearch</th></tr></thead><tbody>
<tr><td align="center"><code>addi</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>addiu</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>andi</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>beq</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>bgtz</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>blez</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td></tr>
<tr><td align="center"><code>bne</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>bgez</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>bgezal</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>bltz</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>bltzal</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>eret</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>mfc0</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>mtc0</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>j</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>jal</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>lb</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>lbu</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td></tr>
<tr><td align="center"><code>lh</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>lhu</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>lui</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>lw</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>ori</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>add</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>addu</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>and</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>break</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>div</code></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>divu</code></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>jalr</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>jr</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>mfhi</code></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>mflo</code></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>mthi</code></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>mtlo</code></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>mult</code></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>multu</code></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>nor</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>or</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>sll</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>sllv</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>slt</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>sltu</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td></tr>
<tr><td align="center"><code>sra</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>srav</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>srl</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>srlv</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>sub</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>subu</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>syscall</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>xor</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>sb</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>sh</code></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center"><code>slti</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>sltiu</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>sw</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr>
<tr><td align="center"><code>xori</code></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
</tbody></table>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="了解-fpga-架构"><a class="header" href="#了解-fpga-架构">了解 FPGA 架构</a></h1>
<p>FPGA（Field Programmable Gate Array）是可编程逻辑阵列的缩写，我们可以在相关计算机软件的帮助下对电路板结构进行编程，来构建我们自己的集成电路板。</p>
<p>Vivado 中的综合阶段会将 HDL 代码转换成底层资源启用和相互连接，并在运行阶段刻入 FPGA 开发板中。</p>
<p>但是如果想进一步提升我们编写的硬件的性能，或多或少需要对板上的资源有一些了解。</p>
<p>FPGA 上的基本结构有以下几类：</p>
<ol>
<li>查找表（Look-Up Table，LUT）：用于实现逻辑运算。</li>
<li>触发器（Flip-Flop，FF）：用于保存 LUT 的运算结果。</li>
<li>电路连接线（wires）：用于连接各部件。</li>
<li>IO 板块（Input/Output pads）：负责 FPGA 与外部的数据交互。</li>
</ol>
<p>这些部件可以组合出最简单的 FPGA 架构，如下图所示：</p>
<p><img src="misc/../asset/misc/fpga-architecture.png" alt="基本的 FPGA 架构" /></p>
<p>此结构尽管已经可以实现所有上层架构，但在吞吐量，资源消耗量和时钟频率等指标上有着较大的限制。</p>
<p><strong>思考</strong>：这些限制来源于哪些物理因素？</p>
<p>当代 FPGA 体系结构将基本部件与其他计算和数据存储模块结合在一起，从而增加了设备的计算密度和效率。</p>
<p>这些其他部件包括：</p>
<ol>
<li>嵌入式存储器（embedded memories）：用于分布式数据存储。</li>
<li>锁相环（Phase-Locked Loops，PLLs）：用于以不同的时钟频率驱动 FPGA 板上的不同部件。</li>
<li>高速串行收发器（high-speed serial transceivers）：利用编码技术实现高速信号传输。</li>
<li>片外存储器控制器（off-chip memory controllers）。</li>
<li>乘积块（multiply-accumulate blocks）：用于加速实现 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> 操作。</li>
</ol>
<p><img src="misc/../asset/misc/fpga-components.png" alt="" /></p>
<h2 id="查找表lut"><a class="header" href="#查找表lut">查找表（LUT）</a></h2>
<p>在数字逻辑课上，查找表经常用于分支决策，但 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> bit 的查找表还可以看做一个映射表：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个给定的存储单元。</p>
<p>通常情况下，Xilinx FPGA 内部使用 6 bit 的查找表。</p>
<p><img src="misc/../asset/misc/lut.png" alt="2 bit 查找表" /></p>
<p><strong>思考</strong>：一个可编程的查找表可实现 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.87998em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.87998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 个不同的映射，为什么？</p>
<h2 id="触发器ff"><a class="header" href="#触发器ff">触发器（FF）</a></h2>
<p>数字逻辑课上讲寄存器时，一定讲到锁存器（latch）与触发器（flip flop）。</p>
<p>FPGA 开发板上使用触发器作为在线存储的寄存器。</p>
<p>FF 寄存器最大的特点是当时钟和时钟使能均为 1 时才会锁存新的数据输入并将其输出到输出端口。</p>
<p><img src="misc/../asset/misc/flip-flop.png" alt="img" /></p>
<p><strong>思考</strong>：为什么用触发器而不用锁存器？</p>
<h2 id="dsp48-模块"><a class="header" href="#dsp48-模块">DSP48 模块</a></h2>
<p>在 Xilinx FPGA 最复杂的可用计算模块被称为 DSP48，如下图所示。</p>
<p><img src="misc/../asset/misc/dsp48.png" alt="DSP48 模块" /></p>
<p>DSP48 模块是 FPGA 架构中的嵌入式算数逻辑单元（ALU），其计算链主要可拆分为三个阶段：</p>
<p>加减单元；以上一阶段结果为输入之一的乘法单元；以及最终的加/减/累加单元。</p>
<p>抽象地来看，它可以实现 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 或 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span> 这样的计算功能。</p>
<h2 id="bram-以及其他存储器件"><a class="header" href="#bram-以及其他存储器件">BRAM 以及其他存储器件</a></h2>
<p>FPGA 开发板上具有可用作随机存取存储器（RAM），只读存储器（ROM）以及移位寄存器等的嵌入式存储元件：Block RAM（BRAM），LUT 和移位寄存器。</p>
<p>BRAM 是一个双端口 RAM 模块，可以提供相对较大的数据保存单元。</p>
<p>FPGA 开发板上有两种大小的 BRAM 存储器：18k 位 BRAM 和 36k 位 BRAM。</p>
<p>这些存储器的双端口性质允许对不同位置进行并行，相同时钟周期的访问。</p>
<p>LUTRAM 则是小型存储器，在设备配置期间（即将 bit 文件写入时）会将 LUT 真值表的内容写入其中。</p>
<p>我们可以利用 LUTRAM 实现不同位数的存储器，FPGA 支持在任何部分实例化 LUTRAM，可提高电路性能。</p>
<p><img src="misc/../asset/misc/shift-register.png" alt="移位存储器" /></p>
<p>上图是一个移位存储器。</p>
<p>移位寄存器是相互连接的一连串寄存器，该结构的目的是沿计算路径提供数据复用。</p>
<p>例如，基本滤波器由一系列乘法器组成，这些乘法器将数据样本与一组系数相乘。 通过使用移位寄存器存储输入数据，内置的数据传输结构在每个时钟周期将数据样本移至链中的下一个乘法器。</p>
<h2 id="lutram"><a class="header" href="#lutram">LUTRAM</a></h2>
<p>在实验 3 中，我们将需要大家使用 LUTRAM 编写 cache line。LUTRAM 的<a href="https://github.com/FDUCSLG/ICS-2021Spring-FDU/blob/master/source/ram/LUTRAM.sv">参考代码</a>已经放在我们的仓库中了。</p>
<p>从行为级描述来看，LUTRAM 的功能十分清晰：</p>
<pre><code class="language-verilog">rview_t [NUM_WORDS - 1:0] mem = 0;

assign rdata = mem[addr];

always_ff @(posedge clk)
if (en) begin
	for (int i = 0; i &lt; NUM_WORDS; i++)
    for (int j = 0; j &lt; NUM_LANES; j++) begin
        if (addr == raddr_t'(i) &amp;&amp; strobe[j])
            mem[i].lanes[j] &lt;= wdata.lanes[j];
    end
end
</code></pre>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="verilator-仿真-1"><a class="header" href="#verilator-仿真-1">Verilator 仿真</a></h1>
<p>在本学期的实验中，除了 Vivado 外，我们会引入 <a href="https://www.veripool.org/wiki/verilator">Verilator</a> 来进行仿真。Verilator 是一个支持 Verilog/SystemVerilog 的周期精确（cycle-accurate）开源仿真器。Verilator 将用 Verilog/SystemVerilog 的 RTL 级描述的模块（module）综合为一个 C++ 模型。这个 C++ 模型一般称为 verilated model，在本学期的实验中是一个叫做 <code>VModel</code> 的 C++ class。然后再通过编写 C++ 代码来提供模型的输入，以及检查模型的输出。在开源领域，特别是与 RISC-V 相关的开源芯片项目，普遍使用 Verilator 进行整个 CPU 的仿真，例如中国科学院大学的 <a href="https://github.com/OSCPU/NutShell">NutShell</a> 和东京大学的 <a href="https://github.com/rsd-devel/rsd">RSD</a>。</p>
<p>使用 Verilator 进行仿真有两个优点。首先，仿真速度一般比 Vivado 更快。以龙芯杯性能测试中的 CoreMark 为例，在 Vivado 上仿真一次通常需要十多分钟，而在 Verilator 上只用一分钟。如果不进行波形图的记录，最快只需要 3 秒就可以完成仿真。其次，使用 C++ 编写测试相比使用 SystemVeriog 而言更具灵活性，例如我们可以很方便的在 C++ 中模拟随机访存的效果，或者是借助外部库 SDL2 将 VGA 模块的输出可视化。</p>
<p>Verilator 目前依然有许多不足之处。首先 Verilator 对 SystemVerilog 的语言支持还非常不完整，比如 unpacked 结构体是不支持的。此外 <code>interface</code>、<code>package</code> 这些关键字虽然支持，但是在功能上还不够完善。为了避免你的 SystemVerilog 代码不能通过 Verilator 的综合和不正确的仿真行为，请<strong>尽量避免</strong>以下事项：</p>
<ul>
<li>不可综合的语法，例如延时。</li>
<li><code>initial</code> 语句。</li>
<li>unpacked 数组、结构体。</li>
<li><code>interface</code>、<code>package</code>、<code>class</code>。</li>
<li>小端序位标号，如 <code>[0:31]</code>。</li>
<li>锁存器。</li>
<li><code>logic</code> 类型的 <code>X</code> 状态和高阻抗 <code>Z</code> 状态。</li>
<li>使用时钟下降沿触发。</li>
<li>异步 reset 和跨时钟域。</li>
<li>尝试屏蔽全局时钟信号。</li>
</ul>
<p>此外，我们建议每个 SystemVerilog 文件只放一个模块，并且文件名和模块名保持一致。例如，<code>SRLatch.sv</code> 里面只放模块 <code>SVLatch</code> 的定义。更详细的内容可以参见 <a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator#LANGUAGE-LIMITATIONS">Verilator 手册中的 “语言限制” 一节</a>。</p>
<h2 id="综合"><a class="header" href="#综合">综合</a></h2>
<p>Verilator 只负责将 RTL 代码综合为 <code>VModel</code>。我们已经提供好了 <code>make verilate</code> 来进行综合。例如， 如果要综合 RefCPU，其顶层模块为 <code>VTop</code>（定义在 <code>source/refcpu/VTop.sv</code> 中），则可以使用下面的命令：</p>
<pre><code class="language-shell">make verilate TARGET=refcpu/VTop
</code></pre>
<p>综合后的文件会放在 <code>build</code> 文件夹下。</p>
<p>如果在综合时出现错误或者警告，请按照错误消息进行修正。你需要确保<strong>你的代码没有任何错误和警告</strong>。Verilator 报告的大部分警告都是有意义的，并且 Verilator 在有警告的时候也会视为综合失败。当你发现有不太明白原因的警告时，请先查看 <a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator">Verilator 手册</a>中对于该警告的描述，确认其原因。如果你确认这个警告不会有影响，可以考虑忽略这个警告。</p>
<p>下面举一个实际的例子。例如，对于下面这个简单的 SR 锁存器的 Verilog 描述：</p>
<pre><code class="language-verilog">module SRLatch (
    input  logic S, R,
    output logic Q, Qn
);
    assign Q  = ~(Qn | R);
    assign Qn = ~(Q  | S);
endmodule
</code></pre>
<p>将其保存到 <code>SVLatch.sv</code>。当我们使用 <code>verilator --cc SVLatch.sv</code> 命令来综合时，会得到类似于下面的警告：</p>
<pre><code class="language-plaintext">%Warning-UNOPT: SRLatch.sv:3:21: Signal unoptimizable: Feedback to public clock or circular logic: 'Qn'
    3 |     output logic Q, Qn
      |                     ^~
                ... Use &quot;/* verilator lint_off UNOPT */&quot; and lint_on around source to disable this message.
                SRLatch.sv:3:21:      Example path: Qn
                SRLatch.sv:5:15:      Example path: ASSIGNW
                SRLatch.sv:3:18:      Example path: Q
                SRLatch.sv:6:15:      Example path: ASSIGNW
                SRLatch.sv:3:21:      Example path: Qn
%Error: Exiting due to 1 warning(s)
</code></pre>
<p>在第一行，我们可以看到警告的类型是 <code>UNOPT</code>。在警告消息里面有一个对该警告的简短的描述。我们可以前往 <a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator#ERRORS-AND-WARNINGS">Verilator 中 “警告和错误” 的文档</a>搜索关于 <code>UNOPT</code> 的详细描述：</p>
<blockquote>
<p>UNOPT</p>
<p>Warns that due to some construct, optimization of the specified signal or block is disabled. The construct should be cleaned up to improve simulation performance.</p>
<p>A less obvious case of this is when a module instantiates two submodules. Inside submodule A, signal I is input and signal O is output. Likewise in submodule B, signal O is an input and I is an output. A loop exists and a UNOPT warning will result if AI &amp; AO both come from and go to combinatorial blocks in both submodules, even if they are unrelated always blocks. This affects performance because Verilator would have to evaluate each submodule multiple times to stabilize the signals crossing between the modules.</p>
<p>Ignoring this warning will only slow simulations, it will simulate correctly.</p>
</blockquote>
<p>事实上就是锁存器的描述中有组合回路。可以通过在代码附近加上 <code>/* verilator lint_off UNOPT */</code> 来消除 <code>UNOPT</code> 警告，即</p>
<pre><code class="language-verilog">    /* verilator lint_off UNOPT */
    assign Q  = ~(Qn | R);
    assign Qn = ~(Q  | S);
    /* verilator lint_on UNOPT */
</code></pre>
<p>这样上述两行 <code>assign</code> 就不会再报告 <code>UNOPT</code> 了。如果想要消除所有文件的 <code>UNOPT</code> 警告，需要前往 <code>verilate/Makefile.verilate.mk</code> 文件，在 <code>SV_WARNINGS</code> 变量后面添加 <code>-Wno-UNOPT</code>：</p>
<pre><code class="language-makefile">SV_WARNINGS = \
	-Wall -Wpedantic \
	-Wno-IMPORTSTAR \
    -Wno-UNOPT
	# add warnings that you wanna ignore.
</code></pre>
<p>当然，请注意在你的 SystemVerilog 代码里面应该<strong>避免组合回路</strong>而不是单纯地消除这个警告！</p>
<p>关于 <code>UNOPT</code> 警告更详细的说明，请参见 <a href="misc/unopt.html">“组合逻辑环与 <code>UNOPT</code>”</a>。</p>
<h2 id="周期精确仿真"><a class="header" href="#周期精确仿真">周期精确仿真</a></h2>
<p>所谓周期精确仿真，是在确定模块输入的情况下，计算出模块在足够长时间后的输出。因此在周期精确仿真中没有延时的概念。可以理解为每次更新都是计算模块在无穷久后处于稳态时的输出。对于 CPU 这种由一个时钟信号驱动的设计，外层代码（C++ 代码）可以通过反复变动时钟信号的值（从 <code>0</code> 变 <code>1</code>，再从 <code>1</code> 变 <code>0</code>），就能得到每个周期内 CPU 的状态。</p>
<p>在 <code>VModel</code> 中，其核心的函数是 <code>eval</code>，它负责计算输入更新后模块的输出。如果 <code>VModel</code> 的时钟信号名为 <code>clk</code>，并且是在时钟上升沿时触发，则我们可以使用类似于下面的 C++ 代码来更新一个周期：</p>
<pre><code class="language-c++">void tick() {
    /**
     *          +--1--+     +--1--+     +--1--+
     *       A  |  B  |  A  |  B  |  A  |  B  |  A
     * clk --0--+     +--0--+     +--0--+     +--0--
     *     ----------&gt;|----------&gt;|----------&gt;|----&gt;
     *      tick()      tick()      tick()      ...
     *     ----------------------------------&gt;| ...
     *      ticks(3)
     */

    clk = 0;
    // 更新内存部分的反馈
    // oresp = ...
    eval();

    // A：此时是在时钟上升沿之前

    clk = 1;
    eval();

    // B：此时是时钟上升沿触发后
}
</code></pre>
<p>具体的例子可以参见 <code>verilate/source/refcpu/VTop/refcpu.cpp</code> 中的 <code>RefCPU::tick</code> 函数的实现。</p>
<h2 id="仿真框架"><a class="header" href="#仿真框架">仿真框架</a></h2>
<p>在本学期的实验中，我们已经提供了 Verilator 下 C++ 仿真的代码框架。代码位于 <code>verilate/source</code> 和 <code>verilate/include</code> 两个文件夹下面。仿真框架已经有内存部分和龙芯杯的 CONFREG 部分的仿真代码。<strong>你只需要按照实验文档的指示提供与你的 CPU 相关的部分的交互代码即可</strong>。仿真的命令为 <code>make vsim</code>。</p>
<p>以 RefCPU 为例，如果想要对 <code>source/refcpu/VTop.sv</code> 进行仿真，只需要指定 <code>TARGET=refcpu/VTop</code>，即</p>
<pre><code class="language-shell">make vsim TARGET=refcpu/VTop
</code></pre>
<p>上面的命令将会把 <code>verilate/source/refcpu/VTop</code> 下的 C++ 代码连同我们提供的仿真框架一起编译，得到一个可执行文件 <code>vmain</code>。这个可执行文件 <code>vmain</code> 是放在 <code>build</code> 文件夹下的。之后运行 <code>vmain</code> 进行正式的仿真。</p>
<p><code>make vsim</code> 命令有如下的参数：</p>
<ul>
<li><code>USE_CLANG</code>：是否使用 LLVM clang 编译？默认为 <code>0</code>，表示使用 GNU G++ 编译。使用 Ubuntu 18.04 的同学需要指定 <code>USE_CLANG=1</code>。</li>
<li><code>VSIM_ARGS</code>：用于指定传给可执行文件 <code>vmain</code> 的参数。例如，<code>make vsim VSIM_ARGS='-h'</code> 可以查看 <code>vmain</code> 支持哪些参数。</li>
<li><code>VSIM_OPT</code>：是否开启编译器优化？默认为 <code>0</code>。注意，<code>VSIM_OPT</code> 为 <code>0</code> 的时候，由 Verilator 生成的 C++ 代码依然会开启优化。这个参数只控制我们的仿真框架的代码。</li>
<li><code>VSIM_SANITIZE</code>：是否开启编译器的 address sanitizer 和 undefined behavior sanitizer？默认为 <code>0</code>。</li>
</ul>
<p>为了加速 C++ 代码的编译，我们建议在 <code>make</code> 的时候加上 <code>-j</code> 选项，允许 make 多进程并行编译 C++ 代码。例如</p>
<pre><code class="language-shell">make vsim -j TARGET=mycpu/VTop USE_CLANG=1
</code></pre>
<h2 id="波形图记录"><a class="header" href="#波形图记录">波形图记录</a></h2>
<p>当仿真出现问题时，我们可以使用输出调试和 GDB 来寻找出错的原因。但是这对于 SystemVerilog 代码的调试并不方便，此时我们可能需要波形图来方便调试。</p>
<p><code>make vsim</code> 在默认情况下不会记录波形图。仿真程序 <code>vmain</code> 是支持记录波形图的。可以用 <code>--fst-trace</code>/<code>-f</code> 选项来指定保存波形图文件的位置。例如</p>
<pre><code class="language-shell">make vsim VSIM_ARGS='-f build/trace.fst'
</code></pre>
<p>将会把波形图保存到当前目录下的 <code>build</code> 文件夹中，波形图文件名为 <code>trace.fst</code>。之后我们可以使用 GTKWave 来查看 FST 格式的波形图。</p>
<p>请注意，开启波形图记录后的仿真速度大约会慢 10 倍。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="组合逻辑环与-unopt"><a class="header" href="#组合逻辑环与-unopt">组合逻辑环与 <code>UNOPT</code></a></h1>
<p>上一节中的 <code>SRLatch</code> 是一个典型的组合逻辑环的例子。在 Vivado 中，<code>SRLatch</code> 可以综合和布线，但是布线阶段 Vivado 也会警告代码中的组合逻辑环：</p>
<p><img src="misc/../asset/misc/sr-latch-warning.png" alt="" /></p>
<p>因为组合逻辑环容易导致电路振荡，从而造成 “仿真通过但上板不过” 的情况。因此，<strong>请务必消除 Vivado 报告的组合逻辑环</strong>。</p>
<p>Verilator 对于组合逻辑环通常报告 <code>UNOPT</code> 或者 <code>UNOPTFLAT</code> 警告，字面意思是不好优化，因为组合逻辑环需要多次迭代后才能得到最终的结果（收敛）。这两种警告的区别在于，一个是 Verilator 生成网表（flatten netlist）前报告的，一个是生成网表后报告的，因此这两种警告对我们而言没有区别。下文中两种警告都用 <code>UNOPT</code> 指代。</p>
<p>Verilator 虽然声称忽略这些警告不会影响仿真的正确性，只会影响仿真的性能。但我们的 CPU 中不应该有组合逻辑环。如果有，大概率是有地方写错了，导致仿真的结果和我们的预期不符。根据我们的经验，大家在写流水线的 hazard 部分时比较容易写出组合逻辑环。</p>
<p>对于 Verilator 报告的 <code>UNOPT</code> 警告，某些情况下不一定是真的组合逻辑环。这是因为，出于仿真性能上的考虑，Verilator 并不是按信号的每一位来单独计算的，通常会把很多信号放一起计算（比如都放在一个 <code>uint32_t</code> 内）。你可以简单地认为 Verilator 是在变量层级生成网表。下面将举几个常见的例子。</p>
<h2 id="例子structwire"><a class="header" href="#例子structwire">例子：<code>StructWire</code></a></h2>
<pre><code class="language-verilog">module StructWire (
    input  logic a,
    output logic d
);
    struct packed {
        logic b, c;
    } block;
    assign block.b = a;
    assign block.c = block.b;
    assign d = block.c;
endmodule
</code></pre>
<p>这段代码单纯地把 <code>a</code> 的值传给 <code>d</code>，中间经过了 <code>block</code>。很明显，<code>a</code> → <code>block.b</code> → <code>block.c</code> → <code>d</code> 没有形成组合逻辑环，但是 Verilator 会把 <code>block</code> 这个变量看作一个整体，于是就出现了 <code>block</code> → <code>block</code> 这个假的逻辑环。此时你只需使用 <code>/* verilator split_var */</code> 来消除警告：</p>
<pre><code class="language-verilog">    struct packed {
        logic b, c;
    } block /* verilator split_var */;
</code></pre>
<p><code>split_var</code> 告诉 Verilator 要把 <code>block</code> 拆成多个变量（可能是 <code>block__DOT__a</code> 和 <code>block__DOT__b</code> 之类的）。这样一来 Verilator 就不会报告 <code>UNOPT</code> 了。</p>
<blockquote>
<p>注意：<code>/* verilator split_var */</code> 需要 Verilator 的版本 ≥ 4.030<sup class="footnote-reference"><a href="#split-var-version">1</a></sup>。如果你用的是 Ubuntu 20.04，那你有可能在使用 4.028。请按照课程仓库首页的指示安装较新版本的 Verilator。我们在测试的时候会使用较高版本的 Verilator。</p>
</blockquote>
<h2 id="例子partialsum"><a class="header" href="#例子partialsum">例子：<code>PartialSum</code></a></h2>
<p>下面是一个异或前缀和的例子：</p>
<pre><code class="language-verilog">module PartialSum (
    input  logic [31:0] a,
    output logic [31:0] b
);
    assign b[0] = a[0];
    for (genvar i = 1; i &lt; 32; i++) begin
        assign b[i] = b[i - 1] ^ a[i];
    end
endmodule
</code></pre>
<p>和 <code>StructWire</code> 一样，从每一位来看，不存在逻辑环。但是 Verilator 会认为有 <code>b</code> → <code>b</code> 的组合逻辑环。所以这里也需要将 <code>b</code> 的每一位分开。但与 <code>StructWire</code> 例子中不一样的是，<code>b</code> 是模块的端口，如果你尝试：</p>
<pre><code class="language-verilog">module PartialSum (
    input  logic [31:0] a,
    output logic [31:0] b /* verilator split_var */
);
</code></pre>
<p>你会收到下面的警告：</p>
<pre><code class="language-plaintext">%Warning-SPLITVAR: PartialSum-SPLITVAR.sv:3:25: 'b' has split_var metacomment but will not be split because it is public
    3 |     output logic [31:0] b /*verilator split_var*/
      |                         ^
                   ... Use &quot;/* verilator lint_off SPLITVAR */&quot; and lint_on around source to disable this message.
%Error: Exiting due to 1 warning(s)
</code></pre>
<p>因为 <code>b</code> 是公开的模块端口，所以 Verilator 拒绝直接将 <code>b</code> 分为多个变量。一个常用的技巧是引入一个私有的中间变量：</p>
<pre><code class="language-verilog">    logic [31:0] c /* verilator split_var */;  // 引入中间变量
    // 对 c 而不是 b 做操作
    assign c[0] = a[0];
    for (genvar i = 1; i &lt; 32; i++) begin
        assign c[i] = c[i - 1] ^ a[i];
    end
    assign b = c;  // 再将 c 整体赋值给 b
</code></pre>
<h2 id="例子alwayscomb"><a class="header" href="#例子alwayscomb">例子：<code>AlwaysComb</code></a></h2>
<p>下面这个例子来自某位同学实验 1 的代码。我们对原始代码做了简化，大致的代码结构如下：</p>
<pre><code class="language-verilog">module AlwaysComb (
    input  logic a, d,
    output logic c, f
);
    always_comb begin
        // ...
        f = ~a;
        // ...
        c = d ^ f;
        // ...
    end
endmodule

module Top (
    input  logic a, b,
    output logic c
);
    logic d, f;
    assign d = b ^ f;
    AlwaysComb inst(.*);
endmodule
</code></pre>
<p>将上面的代码画成原理图，并没有发现逻辑环：</p>
<img src="misc/../asset/misc/always-comb-schematic.svg" style="min-width: 30%; max-width: 60%" />
<p>但是 Verilator 依然会报告 <code>UNOPT</code>。这是因为 Verilator 把 <code>always_comb</code> 语句块作为一个整体处理。Verilator 认为上面的 <code>always_comb</code> 块的输入（敏感列表）有 <code>a</code>、<code>d</code> 和 <code>f</code>，输出有 <code>c</code> 和 <code>f</code>。因此，当 <code>a</code> 发生变化时，触发 <code>always_comb</code> 块，从而 <code>f</code> 也会发生变化。然后 <code>d</code> 也发生变化。由于 <code>d</code> 是 <code>always_comb</code> 块的输入之一，导致 Verilator 认为形成了 <code>f</code> → <code>d</code> → <code>f</code> 的逻辑环。但是明显 <code>d</code> 的变化不会导致 <code>f</code> 变化。消除这个 <code>UNOPT</code> 的一种方法就是将 <code>always_comb</code> 一分为二：</p>
<pre><code class="language-verilog">    always_comb begin
        // ...
        f = ~a;
        // ...
    end
    always_comb begin
        // ...
        c = d ^ f;
        // ...
    end
</code></pre>
<p>事实上这种拆分无论是对 Verilator 还是对一般的事件驱动的仿真器都是有好处的，因为拆分后可以减少不必要的迭代，从而优化仿真性能。从这个例子中可以总结出一个经验：<code>always</code> 块应该避免给变量赋值后使用这个变量，也就是避免变量同时出现在 <code>always</code> 块的输入和输出中。同时我们也鼓励大家不要写过长的 <code>always</code> 块，而是尽量将其分为若干个独立的 <code>always</code> 块。</p>
<h2 id="例子box"><a class="header" href="#例子box">例子：<code>Box</code></a></h2>
<p>下面这段代码中有一个真的组合逻辑环，和一个假的组合逻辑环。请尝试用 <code>verilator --lint-only [文件名]</code> 找出这两个逻辑环。</p>
<pre><code class="language-verilog">typedef logic [31:0] i32;
typedef struct packed {
    logic valid, write_en;
    i32   addr, data;
} req_t;
typedef struct packed {
    logic data_ok;
    i32   data;
} resp_t;

module Box (
    input  logic  clk, resetn,
    input  req_t  req,
    output resp_t resp
);
    i32 stored;

    assign resp.data_ok = req.valid &amp;&amp; req.addr == 32'h19260817;
    always_comb begin
        if (resp.data_ok)
            resp.data = stored;
        else
            resp.data = '0;
    end

    always_ff @(posedge clk)
    if (resetn) begin
        if (req.write_en)
            stored &lt;= resp.data_ok ? req.data : stored;
    end else
        stored &lt;= 32'hdeadbeef;
endmodule

module Fetch (
    input  logic  flush,
    output req_t  req,
    input  resp_t resp
);
    assign {req.valid, req.addr} = {!flush, 32'h19260817};
endmodule

module Core(input logic clk, resetn);
    logic  flush /* verilator public_flat_rd */;
    req_t  req   /* verilator public_flat_rd */;
    resp_t resp  /* verilator public_flat_rd */;
    assign flush = resp.data_ok &amp;&amp; resp.data == '0;

    Fetch trump(.*);
    Box biden(.*);
endmodule
</code></pre>
<div class="footnote-definition" id="split-var-version"><sup class="footnote-definition-label">1</sup>
<p>参见 <a href="https://github.com/verilator/verilator/blob/master/Changes#L329-L336">https://github.com/verilator/verilator/blob/master/Changes#L329-L336</a>。</p>
</div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="使用-gtkwave-1"><a class="header" href="#使用-gtkwave-1">使用 GTKWave</a></h1>
<p>打开样例波形图文件：</p>
<pre><code class="language-shell">gtkwave misc/demo.fst
</code></pre>
<p>一开始面板上是没有信号的。另外有一个文件 <code>misc/demo.gtkw</code> 是与之相关联的配置文件，也可以直接打开：</p>
<pre><code class="language-shell">gtkwave misc/demo.gtkw
</code></pre>
<p><img src="misc/./../asset/misc/demo.png" alt="样例波形图界面" /></p>
<h2 id="添加信号"><a class="header" href="#添加信号">添加信号</a></h2>
<p>当你想加入更多的信号时，点击主菜单中的 “Search” → “Signal Search Tree”（或者使用快捷键 Shift+Alt+T 呼出）。之后会看到下面的窗口：</p>
<p><img src="misc/../asset/misc/gtkwave-search-tree.png" alt="" /></p>
<p>（这个窗口貌似有 BUG，第一次打开后关掉再重开，就展开不了结构树了...）</p>
<p>你也可以用 “Search” → “Signal Search Regexp” 来用文本搜索信号名。</p>
<h2 id="生成新的波形图"><a class="header" href="#生成新的波形图">生成新的波形图</a></h2>
<p>我们的 Verilator 仿真程序一般支持使用 <code>--fst-tract</code>/<code>-f</code> 参数来指定 FST 波形图保存的位置。例如：</p>
<pre><code class="language-shell">make vsim -j VSIM_ARGS=&quot;-f ./build/trace.fst&quot;
</code></pre>
<p>将会在 <code>build</code> 目录下生成一个名为 <code>trace.fst</code> 的波形图文件。之后可以直接用 GTKWave 打开。</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>开学在寝室无所事事？请阅读<a href="misc/../misc/external.html"> GTKWave 用户手册</a>：<i class="fa fa-file-pdf-o"></i> GTKWave 3.3 Wave Analyzer User’s Guide。</p>
<p>不想折腾？请将下面的内容写入 <code>~/.gtkwaverc</code>：</p>
<pre><code class="language-plaintext"># 选择字体
#fontname_signals Lato 16
#fontname_logfile Lato 16
#fontname_waves JetBrains Mono Medium 14

# 快捷键
# “x” 新建一个 marker，“z” 删除一个 marker，“c” 删除所有 marker
accel &quot;/Markers/Drop Named Marker&quot; x
accel &quot;/Markers/Collect Named Marker&quot; z
accel &quot;/Markers/Collect All Named Markers&quot; c

fill_waveform 1
hide_sst 1
hier_grouping 1
hier_max_level 2
left_justify_sigs 1
use_fat_lines 1
use_roundcaps 1
wave_scrolling 1
disable_mouseover 0
highlight_wavewindow 1
splash_disable 1
color_back 041933
color_0 54c231
color_1 54c231
color_vbox 54c231
color_grid 666666
color_trans cc0000
color_vtrans cc0000
color_value eeeeee
color_umark f9fd01
enable_horiz_grid 0
page_divisor 4
</code></pre>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<p><img src="misc/../asset/misc/gtkwave-navigate.gif" alt="浏览波形图的简单示例" /></p>
<p>（上面演示中使用的是 GTK3 版本的 GTKWave）</p>
<h2 id="为什么要用-gtkwave"><a class="header" href="#为什么要用-gtkwave">为什么要用 GTKWave？</a></h2>
<p>GTKWave 看起来挺土的，而且貌似有很多 BUG...</p>
<p>因为没有其它软件了。开源的波形图浏览器只有这一个能打的 <code>:)</code></p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="仓库目录结构"><a class="header" href="#仓库目录结构">仓库目录结构</a></h1>
<p>为了方便大家了解和浏览整个 Git 仓库，这里提供一个对仓库中目录结构和文件的说明。</p>
<h2 id="build"><a class="header" href="#build"><code>build</code></a></h2>
<p><code>build</code> 文件夹下用于放置编译后的文件，包括 Verilator 的综合结果和 C++ 编译过程中的生成物以及最终的可执行文件。这个文件夹下有一个 <code>.gitkeep</code> 文件，用于确保 Git 会记录这个文件夹。使用 <code>make clean</code> 命令会清空 <code>build</code> 文件夹。</p>
<p>根据 Make 的参数，编译过程中会在 <code>build</code> 文件夹下建立不同的子目录。例如 <code>build/gcc+optimized</code> 表示使用 GNU G++ 编译并且参数 <code>VSIM_OPT=1</code>（开启编译优化），而 <code>build/clang+sanitizer</code> 表示使用 LLVM clang 编译（<code>USE_CLANG=1</code>）并且参数 <code>VSIM_SANITZE=1</code>。具体的规则参见文件 <code>Makefile</code> 中变量 <code>BUILD_ROOT</code> 的设置。</p>
<h2 id="doc"><a class="header" href="#doc"><code>doc</code></a></h2>
<p>本学期实验的所有文档都位于此目录下。<code>doc/src</code> 内是文档的原始 Markdown 文件，<code>doc/book</code> 是使用 mdBook 编译后得到的网页文件。文档中使用的图片均放在 <code>doc/src/asset</code> 目录下。</p>
<h2 id="misc"><a class="header" href="#misc"><code>misc</code></a></h2>
<p>放置各种各样的资源文件，比如测试的内存加载文件（.coe）。龙芯杯的性能测试的内存文件放在 <code>misc/nscscc</code> 目录下，以方便 Verilator 仿真。</p>
<h2 id="source"><a class="header" href="#source"><code>source</code></a></h2>
<p>RTL 源代码所在的文件夹。</p>
<h3 id="sourceinclude"><a class="header" href="#sourceinclude"><code>source/include</code></a></h3>
<p>所有的 SystemVerilog 头文件（.svh）都放在这个文件下。<code>source/include/common.svh</code> 内包含一些通用的定义。<code>source/include/refcpu</code> 下放的是和 RefCPU 相关的头文件。如果你需要使用头文件，可以放在 <code>source/include/mycpu</code> 目录下。</p>
<h3 id="sourcemycpu"><a class="header" href="#sourcemycpu"><code>source/mycpu</code></a></h3>
<p>你的 SystemVerilog 源代码文件夹。这个文件夹一开始已经包含了一些模块的定义和实现：</p>
<ul>
<li><code>add_sources.tcl</code>：用于将你的 CPU 的源代码加入到 Vivado 工程中的 Tcl 脚本。</li>
<li><code>DCache.sv</code>、<code>ICache.sv</code>：数据缓存和指令缓存。这两个文件会在实验 3 的时候用到。一开始是直接用数据缓存当指令缓存用，并没有分别实现。</li>
<li><code>MyArbiter.sv</code>：你的访存仲裁器。这个文件将会在实验 2 用到。</li>
<li><code>MyCore.sv</code>：你的流水线部分。<code>MyCore</code> 这个模块一共有 6 个接口：<code>clk</code>、<code>resetn</code>、<code>ireq</code>、<code>iresp</code>、<code>dreq</code>、<code>dresp</code>，分别表示时钟信号、复位信号、指令访存请求、指令访存回复、数据访存请求和数据访存回复。其中指令访存和数据访存涉及到的结构体的定义都位于 <code>source/include/common.svh</code> 中。</li>
<li><code>mycpu_top.sv</code>：接入龙芯杯的测试的顶层模块。</li>
<li><code>SRAMTop.sv</code>：使用类 SRAM 接口时 CPU 的顶层模块。</li>
<li><code>VTop.sv</code>：使用 AXI 接口时或者进行 Verilator 仿真时 CPU 的顶层模块。</li>
<li><code>VCacheTop.sv</code>：测试缓存时的顶层模块。</li>
</ul>
<h3 id="sourcerefcpu"><a class="header" href="#sourcerefcpu"><code>source/refcpu</code></a></h3>
<p>RefCPU 的源代码。目录结构和 <code>source/mycpu</code> 是类似的。</p>
<h3 id="sourceram"><a class="header" href="#sourceram"><code>source/ram</code></a></h3>
<p>存放 BRAM 和 LUTRAM 模块和它们的测试文件。</p>
<h3 id="sourceutil"><a class="header" href="#sourceutil"><code>source/util</code></a></h3>
<p>我们提供的辅助模块，主要是各种总线之间的转接桥。其中 <code>CBusArbiter.sv</code> 是我们提供的仲裁器的实现。你可以直接使用 <code>CBusArbiter</code> 而不需要实现自己的仲裁器 <code>MyArbiter</code>。</p>
<h2 id="verilate"><a class="header" href="#verilate"><code>verilate</code></a></h2>
<p>用于存放 Verilator 仿真时用到的 C++ 代码。<code>verilate/include</code> 是共用的 C++ 头文件，<code>verilate/source</code> 下是所有的 C++ 代码。直接放在 <code>verilate/source</code> 目录下的是通用的 C++ 代码。针对不同的模块的测试，专用的代码会放在这个文件夹的子目录下。例如 <code>verilate/source/refcpu/VTop</code> 就是用于存放测试 <code>source/refcpu/VTop.sv</code> 这个顶层模块的所有 C++ 代码。</p>
<p>在执行 <code>make vsim</code> 命令时，参数 <code>TARGET</code> 可以指定编译哪个顶层模块对应的 C++ 代码。默认 <code>TARGET=refcpu/VTop</code>，即编译 <code>verilate/source/refcpu/VTop</code> 下的代码。编译后的可执行文件名为 <code>vmain</code>，会放到 <code>build</code> 文件夹下的对应位置，例如 <code>build/gcc/refcpu/VTop/vmain</code>。</p>
<h2 id="vivado"><a class="header" href="#vivado"><code>vivado</code></a></h2>
<p>用于存放龙芯杯的测试。龙芯杯的功能测试被分为了测试 1 至测试 4，分别放在 <code>vivado/test1</code> 到 <code>vivado/test4</code> 这四个目录下。<code>vivado/test1_naive</code> 的测试内容和 <code>vivado/test1</code> 的测试内容相同，只有顶层使用的接口不同。<code>vivado/test5</code> 是龙芯杯的所有性能测试。此外除了 <code>vivado/test1_naive</code> 使用固定延时的类 SRAM 接口外，其余测试使用的都是有随机延时的 AXI 接口。</p>
<p>Vivado 的工程文件（.xpr）通常放在名为 <code>run_vivado</code> 的文件夹下，例如 <code>vivado/test1/soc_axi_func/run_vivado/mycpu_prj1/mycpu.xpr</code>。可以使用 Vivado 直接打开这个工程文件。如果某个测试需要建立多个工程，请注意复制对应的文件夹后再用 Vivado 打开。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h1>
<p>关于实验内容的答疑，请前往 <a href="https://fducslg.slack.com">FDUCSLG</a> 的 Slack 平台的 #sig-architecture 频道提问。如果你不想公开提问，可以单独询问助教。</p>
<p>本页面不定期更新。</p>
<h3 id="为什么运行-make-vsim-显示-coe-file-should-begin-with-memory_initialization_radix--"><a class="header" href="#为什么运行-make-vsim-显示-coe-file-should-begin-with-memory_initialization_radix--">为什么运行 <code>make vsim</code> 显示 “<code>COE file should begin with &quot;memory_initialization_radix = &quot;</code>”？</a></h3>
<p>请检查 <code>misc/nscscc</code> 目录下的 <code>.coe</code> 文件内容是否正确。它们都是 Linux 软链接，正常情况下，可以使用 <code>ls -l misc/nscscc</code> 查看到软链接到位置：</p>
<pre><code class="language-shell">$ ls -l misc/nscscc
total 3400
lrwxrwxrwx 1 riteme riteme      58 Feb 27 12:55 bitcount.coe -&gt; ../../vivado/test5/soft/perf_func/obj/bitcount/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      61 Feb 27 12:55 bubble_sort.coe -&gt; ../../vivado/test5/soft/perf_func/obj/bubble_sort/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      58 Feb 27 12:56 coremark.coe -&gt; ../../vivado/test5/soft/perf_func/obj/coremark/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      55 Feb 27 12:56 crc32.coe -&gt; ../../vivado/test5/soft/perf_func/obj/crc32/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      59 Feb 27 12:56 dhrystone.coe -&gt; ../../vivado/test5/soft/perf_func/obj/dhrystone/axi_ram.coe
-rwxr-xr-x 1 riteme riteme 1299476 Feb 20 12:07 func_test.coe
-rw-r--r-- 1 riteme riteme 2157055 Feb 20 12:07 func_test.txt
lrwxrwxrwx 1 riteme riteme      60 Feb 27 12:57 quick_sort.coe -&gt; ../../vivado/test5/soft/perf_func/obj/quick_sort/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      61 Feb 27 12:57 select_sort.coe -&gt; ../../vivado/test5/soft/perf_func/obj/select_sort/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      53 Feb 27 12:57 sha.coe -&gt; ../../vivado/test5/soft/perf_func/obj/sha/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      61 Feb 27 12:57 stream_copy.coe -&gt; ../../vivado/test5/soft/perf_func/obj/stream_copy/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      62 Feb 27 12:58 stringsearch.coe -&gt; ../../vivado/test5/soft/perf_func/obj/stringsearch/axi_ram.coe
lrwxrwxrwx 1 riteme riteme      45 Mar 19 23:27 test1.coe -&gt; ../../vivado/test1/soft/func/obj/inst_ram.coe
lrwxrwxrwx 1 riteme riteme      35 Mar 19 23:27 test1.txt -&gt; ../../vivado/test1/golden_trace.txt
lrwxrwxrwx 1 riteme riteme      45 Mar 19 23:27 test2.coe -&gt; ../../vivado/test2/soft/func/obj/inst_ram.coe
lrwxrwxrwx 1 riteme riteme      35 Mar 19 23:27 test2.txt -&gt; ../../vivado/test2/golden_trace.txt
lrwxrwxrwx 1 riteme riteme      45 Mar 19 23:27 test3.coe -&gt; ../../vivado/test3/soft/func/obj/inst_ram.coe
lrwxrwxrwx 1 riteme riteme      35 Mar 19 23:27 test3.txt -&gt; ../../vivado/test3/golden_trace.txt
lrwxrwxrwx 1 riteme riteme      45 Mar 19 23:27 test4.coe -&gt; ../../vivado/test4/soft/func/obj/inst_ram.coe
</code></pre>
<p>如果你的输出没有显示链接到 <code>vivado</code> 目录，说明你有可能是在非 *nix 环境下（比如 Windows）做的 git clone。你可以尝试重新 clone，或者直接在 <code>VSIM_ARGS</code> 中手动指定 <code>-m</code> 和 <code>-r</code> 参数。</p>
<h3 id="为什么编译时报错-undefined-reference-to-"><a class="header" href="#为什么编译时报错-undefined-reference-to-">为什么编译时报错 “<code>undefined reference to ...</code>”？</a></h3>
<p>一般是我们更新了代码后会出现这种问题。你可以尝试先 <code>make clean</code> 后再重新编译。</p>
<h3 id="为什么-verilator-会报告-unoptunoptflat"><a class="header" href="#为什么-verilator-会报告-unoptunoptflat">为什么 Verilator 会报告 <code>UNOPT</code>/<code>UNOPTFLAT</code>？</a></h3>
<p>这是因为你的代码中可能存在组合逻辑环。请根据 Verilator 输出的文件位置检查是否真的有逻辑环。</p>
<p>如果你认为并不存在逻辑环，并且 Vivado 布线时也没有报告逻辑环，有可能是遇到了 <a href="misc/unopt.html">“组合逻辑环与 <code>UNOPT</code>”</a> 中提到的情形。</p>
<h3 id="为什么仿真一直在跑却没有显示-functional-test-point-pass"><a class="header" href="#为什么仿真一直在跑却没有显示-functional-test-point-pass">为什么仿真一直在跑却没有显示 “Functional Test Point PASS!!!”？</a></h3>
<p>有时候你甚至会发现第一个点已经显示通过了，但是第二个点的 “PASS!!!” 一直没有出现。这种情况可能是你的流水线 writeback 阶段没有写入寄存器，导致 trace 没有进行比对，因此也没有发现你 CPU 的错误。</p>
<p>龙芯的测试是在信号 <code>debug_wb_rf_wen</code> 不为零的时钟上升沿进行比对。你在仿真的时候可以注意下波形图中 <code>debug_wb_rf_wen</code> 这一行是否出现了 <code>4'hf</code>，如果出现了则说明 trace 比对正在进行。如果全程为 <code>0</code> 则说明你的流水线没有写入寄存器，或者是 <code>debug_*</code> 信号连接出错。</p>
<h3 id="为什么-vivado-上的仿真非常慢要跑十多分钟甚至是一个小时"><a class="header" href="#为什么-vivado-上的仿真非常慢要跑十多分钟甚至是一个小时">为什么 Vivado 上的仿真非常慢？要跑十多分钟甚至是一个小时？</a></h3>
<p>我们提供的测试的设置中，默认是会在仿真过程中记录所有的信号。这样在测试不通过时，可以查看所有的信号来寻找问题，方便大家调试。由于 Vivado 自带的 xsim 仿真器本身性能不高，如果需要记录所有的信号，势必会严重拖慢仿真。如果你想加快仿真速度，可以考虑关闭完整的信号记录。</p>
<p>依次点击 Vivado 顶部菜单栏的 “Tools” → “Settings...”，然后在下图所示的窗口中按照红色矩形框的指示，将 <code>xsim.simulate.log_all_signals</code> 右侧的勾选框取消。</p>
<p><img src="asset/faq/log-all-signals.png" alt="记录所有信号的选项" /></p>
<p>然后点击 “OK” 保存设置。之后重新启动仿真。</p>
<h3 id="我能拿-a-吗"><a class="header" href="#我能拿-a-吗">我能拿 A 吗？</a></h3>
<p>未来可期。</p>
<h3 id="可以退课吗"><a class="header" href="#可以退课吗">可以退课吗？</a></h3>
<p>耗子尾汁。</p>
<h3 id="这课保-b-吗"><a class="header" href="#这课保-b-吗">这课保 B+ 吗？</a></h3>
<p>无可奉告。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="贡献者"><a class="header" href="#贡献者">贡献者</a></h1>
<ul>
<li>谭一凡（<a href="https://github.com/Tan-YiFan">@Tan-YiFan</a>）</li>
<li>薛振梁（<a href="https://github.com/riteme">@riteme</a>）</li>
<li>彭润宇（<a href="https://github.com/Pryest">@Pryest</a>）</li>
<li>韩晓宇（<a href="https://github.com/HatsuneHan">@HatsuneHan</a>）</li>
</ul>
<p>Powered by <a href="https://github.com/rust-lang/mdBook">mdBook</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
